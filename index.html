<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Impossible Fishbowl</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#000}
canvas{display:block}
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
'use strict';

// ================================================================
// THE IMPOSSIBLE FISHBOWL
// A mesmerizing real-time 3D aquarium ecosystem
// ================================================================

// --- Seeded RNG for deterministic environment ---
function mkRng(seed) {
  let s = seed;
  return function() { s = (s * 9301 + 49297) % 233280; return s / 233280; };
}
const rng = mkRng(42);

// ================================================================
// RENDERER & SCENE
// ================================================================

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x030912);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);

// ================================================================
// LIGHTING
// ================================================================

scene.add(new THREE.AmbientLight(0x334466, 0.5));

const sunLight = new THREE.DirectionalLight(0xffeedd, 0.9);
sunLight.position.set(3, 10, 5);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(1024, 1024);
Object.assign(sunLight.shadow.camera, { near: 1, far: 25, left: -7, right: 7, top: 7, bottom: -7 });
scene.add(sunLight);

const fillLight = new THREE.PointLight(0x446688, 0.3, 15);
fillLight.position.set(-3, -2, 4);
scene.add(fillLight);

const underwaterGlow = new THREE.PointLight(0x2277aa, 0.4, 10);
underwaterGlow.position.set(0, -2, 0);
scene.add(underwaterGlow);

// ================================================================
// CONSTANTS
// ================================================================

const BOWL_RADIUS = 5;
const BOWL_THETA_START = Math.acos(0.6);        // ~0.927 rad
const BOWL_OPENING_Y = BOWL_RADIUS * 0.6;       // 3.0
const BOWL_OPENING_R = BOWL_RADIUS * Math.sin(BOWL_THETA_START); // 4.0
const WATER_Y = 2.5;
const SAND_Y = -4.0;
const SAND_RADIUS = Math.sqrt(BOWL_RADIUS * BOWL_RADIUS - SAND_Y * SAND_Y) - 0.25; // ~2.75

// ================================================================
// GLASS BOWL
// ================================================================

const bowlGeo = new THREE.SphereGeometry(
  BOWL_RADIUS, 64, 48,
  0, Math.PI * 2,
  BOWL_THETA_START, Math.PI - BOWL_THETA_START
);

const glassMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  side: THREE.DoubleSide,
  vertexShader: `
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    void main() {
      vNormal = normalize(mat3(modelMatrix) * normal);
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    void main() {
      vec3 viewDir = normalize(cameraPosition - vWorldPos);
      vec3 n = gl_FrontFacing ? vNormal : -vNormal;
      float fresnel = pow(1.0 - abs(dot(n, viewDir)), 3.0);
      vec3 color = mix(vec3(0.7, 0.85, 0.95), vec3(0.95, 0.97, 1.0), fresnel);

      vec3 lightDir = normalize(vec3(3.0, 10.0, 5.0));
      vec3 h = normalize(lightDir + viewDir);
      float spec = pow(max(dot(n, h), 0.0), 128.0);
      color += spec * 0.6;

      float alpha = mix(0.04, 0.3, fresnel) + spec * 0.4;
      gl_FragColor = vec4(color, alpha);
    }
  `
});

scene.add(new THREE.Mesh(bowlGeo, glassMat));

// Bowl rim
const rimGeo = new THREE.TorusGeometry(BOWL_OPENING_R, 0.1, 12, 64);
const rimMat = new THREE.MeshStandardMaterial({
  color: 0xbbccdd, roughness: 0.05, metalness: 0.2,
  transparent: true, opacity: 0.5
});
const rim = new THREE.Mesh(rimGeo, rimMat);
rim.rotation.x = Math.PI / 2;
rim.position.y = BOWL_OPENING_Y;
scene.add(rim);

// ================================================================
// WATER SURFACE
// ================================================================

const waterGeo = new THREE.CircleGeometry(
  Math.sqrt(BOWL_RADIUS * BOWL_RADIUS - WATER_Y * WATER_Y) - 0.15, 64
);
waterGeo.rotateX(-Math.PI / 2);

const waterMat = new THREE.ShaderMaterial({
  transparent: true, depthWrite: false, side: THREE.DoubleSide,
  uniforms: { uTime: { value: 0 } },
  vertexShader: `
    uniform float uTime;
    varying vec2 vUv;
    void main() {
      vUv = uv;
      vec3 pos = position;
      pos.y += sin(pos.x * 2.0 + uTime * 0.8) * 0.04
             + cos(pos.z * 2.5 + uTime * 0.6) * 0.03;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `,
  fragmentShader: `
    varying vec2 vUv;
    void main() {
      float d = length(vUv - 0.5) * 2.0;
      float alpha = 0.12 * (1.0 - d * 0.3);
      gl_FragColor = vec4(0.3, 0.55, 0.7, alpha);
    }
  `
});
const waterSurface = new THREE.Mesh(waterGeo, waterMat);
waterSurface.position.y = WATER_Y;
scene.add(waterSurface);

// ================================================================
// SAND FLOOR
// ================================================================

const sandCanvas = document.createElement('canvas');
sandCanvas.width = sandCanvas.height = 512;
const sCtx = sandCanvas.getContext('2d');
sCtx.fillStyle = '#c4a882';
sCtx.fillRect(0, 0, 512, 512);
for (let i = 0; i < 40000; i++) {
  const b = rng() * 30 - 15 | 0;
  sCtx.fillStyle = `rgb(${196 + b},${168 + b},${130 + b})`;
  sCtx.fillRect(rng() * 512, rng() * 512, 1 + rng() * 2, 1 + rng() * 2);
}
const sandTexture = new THREE.CanvasTexture(sandCanvas);
sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping;

const sandGeo = new THREE.CircleGeometry(SAND_RADIUS, 64);
sandGeo.rotateX(-Math.PI / 2);
const sp = sandGeo.attributes.position;
for (let i = 0; i < sp.count; i++) {
  const x = sp.getX(i), z = sp.getZ(i);
  const d = Math.sqrt(x * x + z * z) / SAND_RADIUS;
  sp.setY(i, sp.getY(i) + rng() * 0.12 * (1 - d));
}
sandGeo.computeVertexNormals();

const sand = new THREE.Mesh(sandGeo, new THREE.MeshStandardMaterial({
  map: sandTexture, roughness: 0.95, metalness: 0
}));
sand.position.y = SAND_Y;
sand.receiveShadow = true;
scene.add(sand);

// ================================================================
// ROCKS
// ================================================================

function createRock(size, x, z) {
  const geo = new THREE.IcosahedronGeometry(size, 1);
  const p = geo.attributes.position;
  for (let i = 0; i < p.count; i++) {
    const n = 0.7 + rng() * 0.6;
    p.setXYZ(i, p.getX(i) * n, p.getY(i) * (0.5 + rng() * 0.3), p.getZ(i) * n);
  }
  geo.computeVertexNormals();
  const shade = 0.2 + rng() * 0.15;
  const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
    color: new THREE.Color(shade, shade * 0.9, shade * 0.8), roughness: 0.9
  }));
  mesh.position.set(x, SAND_Y + size * 0.3, z);
  mesh.rotation.set(rng() * Math.PI, rng() * Math.PI, rng() * Math.PI);
  mesh.castShadow = mesh.receiveShadow = true;
  scene.add(mesh);
  return mesh;
}

createRock(0.5, -1.5, 1.0);
createRock(0.35, 1.2, 1.5);
createRock(0.45, -0.6, -1.5);
createRock(0.55, 2.0, -0.5);
createRock(0.35, -2.0, -0.3);
createRock(0.3, 0.3, -2.0);

// ================================================================
// CORAL
// ================================================================

function createCoral(x, z, color, height, branchCount) {
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.55 });

  // Trunk
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry(0.04, 0.12, height, 8), mat
  );
  trunk.position.y = height / 2;
  group.add(trunk);

  // Branches
  for (let i = 0; i < branchCount; i++) {
    const bh = height * (0.3 + rng() * 0.4);
    const branch = new THREE.Mesh(
      new THREE.CylinderGeometry(0.02, 0.06, bh, 6), mat
    );
    const startY = height * (0.3 + rng() * 0.5);
    const angle = rng() * Math.PI * 2;
    const tilt = 0.3 + rng() * 0.5;
    branch.position.set(Math.sin(angle) * 0.15, startY + bh * 0.4, Math.cos(angle) * 0.15);
    branch.rotation.set(tilt * Math.cos(angle), 0, tilt * Math.sin(angle));
    group.add(branch);

    // Tip bulb
    const bulb = new THREE.Mesh(
      new THREE.SphereGeometry(0.04 + rng() * 0.04, 8, 8), mat
    );
    bulb.position.set(
      branch.position.x + Math.sin(angle) * bh * 0.3,
      startY + bh * 0.8,
      branch.position.z + Math.cos(angle) * bh * 0.3
    );
    group.add(bulb);
  }

  group.position.set(x, SAND_Y + 0.05, z);
  scene.add(group);
  return group;
}

createCoral(1.5, -1.0, 0xff5566, 1.5, 5);
createCoral(-1.2, -1.8, 0xff8844, 1.2, 4);
createCoral(-0.3, 2.0, 0xaa44cc, 1.0, 3);
createCoral(0.8, 1.8, 0xff6699, 0.8, 3);

// Seaweed (simple waving planes, will animate later)
function createSeaweed(x, z, height, color) {
  const geo = new THREE.PlaneGeometry(0.25, height, 1, 8);
  const p = geo.attributes.position;
  for (let i = 0; i < p.count; i++) {
    const y = p.getY(i);
    const t = (y / height + 0.5);
    p.setX(i, p.getX(i) + Math.sin(t * 2) * 0.1);
  }
  geo.computeVertexNormals();
  const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
    color, side: THREE.DoubleSide, transparent: true, opacity: 0.85
  }));
  mesh.position.set(x, SAND_Y + height * 0.5, z);
  mesh.rotation.y = rng() * Math.PI;
  scene.add(mesh);
  return mesh;
}

const seaweeds = [];
seaweeds.push(createSeaweed(-1.8, 0.5, 2.0, 0x2d6b3a));
seaweeds.push(createSeaweed(1.6, 0.8, 1.5, 0x3a7d4a));
seaweeds.push(createSeaweed(-0.8, 2.0, 1.8, 0x1f5c2e));
seaweeds.push(createSeaweed(0.5, -2.2, 1.3, 0x2a6e38));

// ================================================================
// FLOATING PARTICLES (plankton / debris)
// ================================================================

const pCanvas = document.createElement('canvas');
pCanvas.width = pCanvas.height = 32;
const pCtx = pCanvas.getContext('2d');
const pGrad = pCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
pGrad.addColorStop(0, 'rgba(200,220,255,0.9)');
pGrad.addColorStop(1, 'rgba(200,220,255,0)');
pCtx.fillStyle = pGrad;
pCtx.fillRect(0, 0, 32, 32);
const pTex = new THREE.CanvasTexture(pCanvas);

const PARTICLE_COUNT = 250;
const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
const particleSpeeds = new Float32Array(PARTICLE_COUNT);
for (let i = 0; i < PARTICLE_COUNT; i++) {
  const angle = rng() * Math.PI * 2;
  const r = rng() * 3.0;
  const y = SAND_Y + 0.5 + rng() * (WATER_Y - SAND_Y - 1);
  particlePositions[i * 3] = Math.cos(angle) * r;
  particlePositions[i * 3 + 1] = y;
  particlePositions[i * 3 + 2] = Math.sin(angle) * r;
  particleSpeeds[i] = 0.005 + rng() * 0.01;
}
const particleGeo = new THREE.BufferGeometry();
particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

const particles = new THREE.Points(particleGeo, new THREE.PointsMaterial({
  map: pTex, size: 0.06, transparent: true, opacity: 0.5,
  blending: THREE.AdditiveBlending, depthWrite: false
}));
scene.add(particles);

// ================================================================
// BACKGROUND
// ================================================================

const bgMat = new THREE.ShaderMaterial({
  side: THREE.BackSide, depthWrite: false,
  uniforms: { uTime: { value: 0 } },
  vertexShader: `
    varying vec3 vPos;
    void main() {
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    varying vec3 vPos;
    void main() {
      float y = normalize(vPos).y;
      float s = sin(uTime * 0.03) * 0.01;
      vec3 top = vec3(0.06 + s, 0.09, 0.16);
      vec3 mid = vec3(0.03, 0.06 + s, 0.12);
      vec3 bot = vec3(0.01, 0.02, 0.04);
      vec3 c = mix(bot, mid, smoothstep(-0.5, 0.0, y));
      c = mix(c, top, smoothstep(0.0, 0.5, y));
      gl_FragColor = vec4(c, 1.0);
    }
  `
});
const bgSphere = new THREE.Mesh(new THREE.SphereGeometry(45, 16, 16), bgMat);
bgSphere.renderOrder = -100;
scene.add(bgSphere);

// ================================================================
// BOIDS / FISH SYSTEM
// ================================================================

const BOWL_INNER = BOWL_RADIUS - 0.6; // swim boundary
const fishList = [];

// --- Fish body geometry builder ---
function buildFishBody(key, size) {
  const SEGS = 12, RING = 8;
  const len = size * 2.5;
  const hs = key === 'medium' ? 1.4 : 1.0; // angelfish are taller
  const pos = [], idx = [];

  for (let s = 0; s <= SEGS; s++) {
    const t = s / SEGS; // 0=tail, 1=head
    const z = (0.5 - t) * len; // tail at +z, head at -z (faces -z for lookAt)
    let base = Math.sin(t * Math.PI);
    if (t < 0.12) base *= t / 0.12;
    const rScale = key === 'small' ? 0.35 : key === 'medium' ? 0.28 : 0.42;
    const r = base * rScale * size;

    for (let j = 0; j <= RING; j++) {
      const a = (j / RING) * Math.PI * 2;
      pos.push(Math.cos(a) * r, Math.sin(a) * r * hs, z);
    }
  }

  for (let s = 0; s < SEGS; s++) {
    for (let j = 0; j < RING; j++) {
      const a = s * (RING + 1) + j;
      idx.push(a, a + RING + 1, a + 1, a + 1, a + RING + 1, a + RING + 2);
    }
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
  geo.setIndex(idx);
  geo.computeVertexNormals();
  return { geo, rest: new Float32Array(pos), len, SEGS, RING };
}

// Reusable objects for smooth rotation
const _lookTarget = new THREE.Vector3();
const _lookMat = new THREE.Matrix4();
const _targetQuat = new THREE.Quaternion();
const _up = new THREE.Vector3(0, 1, 0);

class Fish {
  constructor(species, speciesKey, pos) {
    this.species = species;
    this.speciesKey = speciesKey;
    this.pos = pos.clone();
    this.vel = new THREE.Vector3(
      (rng() - 0.5) * 2, (rng() - 0.5) * 0.5, (rng() - 0.5) * 2
    ).normalize().multiplyScalar(species.speed * 0.5);
    this.acc = new THREE.Vector3();
    this.age = 0;
    this.alive = true;
    this.swimPhase = rng() * Math.PI * 2;
    this.opacity = 1;

    const color = species.colors[Math.floor(rng() * species.colors.length)];
    this.mat = new THREE.MeshStandardMaterial({
      color, roughness: 0.3, metalness: 0.15, side: THREE.DoubleSide
    });

    this.mesh = new THREE.Group();

    // Body
    this.body = buildFishBody(speciesKey, species.size);
    this.bodyMesh = new THREE.Mesh(this.body.geo, this.mat);
    this.mesh.add(this.bodyMesh);

    // Tail fin
    const tMul = speciesKey === 'large' ? 1.4 : speciesKey === 'medium' ? 0.8 : 0.5;
    const tailGeo = new THREE.PlaneGeometry(
      species.size * tMul * 0.7,
      species.size * tMul * 1.1,
      1, 4
    );
    // V-notch: indent center of trailing edge
    const tv = tailGeo.attributes.position;
    for (let i = 0; i < tv.count; i++) {
      const y = tv.getY(i);
      const x = tv.getX(i);
      const indentFactor = 1 - Math.abs(y) / (species.size * tMul * 0.55);
      if (x > 0) tv.setX(i, x - indentFactor * species.size * tMul * 0.15);
    }
    tailGeo.computeVertexNormals();
    this.tailMesh = new THREE.Mesh(tailGeo, this.mat);
    this.tailMesh.rotation.y = Math.PI / 2;
    this.tailMesh.position.z = this.body.len * 0.46;
    this.mesh.add(this.tailMesh);

    // Dorsal fin
    const dh = speciesKey === 'large' ? 0.5 : speciesKey === 'medium' ? 0.5 : 0.22;
    const dorsalGeo = new THREE.PlaneGeometry(this.body.len * 0.3, species.size * dh, 4, 1);
    // Taper dorsal fin toward tail
    const dv = dorsalGeo.attributes.position;
    for (let i = 0; i < dv.count; i++) {
      const x = dv.getX(i);
      if (x > 0) dv.setY(i, dv.getY(i) * (1 - x / (this.body.len * 0.15) * 0.4));
    }
    dorsalGeo.computeVertexNormals();
    this.dorsalMesh = new THREE.Mesh(dorsalGeo, this.mat);
    this.dorsalMesh.rotation.y = Math.PI / 2;
    const bodyR = species.size * (speciesKey === 'small' ? 0.35 : speciesKey === 'medium' ? 0.28 : 0.42);
    const hsFin = speciesKey === 'medium' ? 1.4 : 1.0;
    this.dorsalMesh.position.set(0, bodyR * hsFin + species.size * dh * 0.3, -this.body.len * 0.05);
    this.mesh.add(this.dorsalMesh);

    // Pectoral fins (small side fins)
    const pSize = species.size * 0.25;
    const pGeo = new THREE.PlaneGeometry(pSize, pSize * 1.5);
    this.leftFin = new THREE.Mesh(pGeo, this.mat);
    this.leftFin.position.set(bodyR * 0.9, -species.size * 0.05, -this.body.len * 0.15);
    this.leftFin.rotation.set(0.2, 0.4, -0.3);
    this.mesh.add(this.leftFin);

    this.rightFin = new THREE.Mesh(pGeo, this.mat);
    this.rightFin.position.set(-bodyR * 0.9, -species.size * 0.05, -this.body.len * 0.15);
    this.rightFin.rotation.set(0.2, -0.4, 0.3);
    this.mesh.add(this.rightFin);

    // Eyes
    const eyeGeo = new THREE.SphereGeometry(species.size * 0.06, 6, 6);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.1, metalness: 0.5 });
    const eyeZ = -this.body.len * 0.4;
    const eyeX = species.size * 0.14;
    const eyeY = species.size * 0.06;
    this.mesh.add(Object.assign(new THREE.Mesh(eyeGeo, eyeMat), { position: new THREE.Vector3(eyeX, eyeY, eyeZ) }));
    this.mesh.add(Object.assign(new THREE.Mesh(eyeGeo, eyeMat), { position: new THREE.Vector3(-eyeX, eyeY, eyeZ) }));

    this.mesh.position.copy(pos);
    scene.add(this.mesh);
  }

  applyForce(f) { this.acc.add(f); }

  update(dt, time) {
    this.vel.add(this.acc);
    const spd = this.vel.length();
    if (spd > this.species.maxSpeed) this.vel.multiplyScalar(this.species.maxSpeed / spd);
    if (spd < this.species.speed * 0.3) this.vel.normalize().multiplyScalar(this.species.speed * 0.3);

    this.pos.addScaledVector(this.vel, dt * 60);
    this.acc.set(0, 0, 0);
    this.age += dt;

    this.mesh.position.copy(this.pos);

    // Smooth rotation toward velocity
    if (spd > 0.01) {
      _lookTarget.copy(this.pos).add(this.vel);
      _lookMat.lookAt(this.pos, _lookTarget, _up);
      _targetQuat.setFromRotationMatrix(_lookMat);
      this.mesh.quaternion.slerp(_targetQuat, Math.min(1, dt * 6));
    }

    // Body undulation (sine wave along spine, stronger at tail)
    const bd = this.body;
    const positions = bd.geo.attributes.position;
    const swimFreq = 4 + spd * 2;
    const phase = this.swimPhase + time * swimFreq;

    for (let s = 0; s <= bd.SEGS; s++) {
      const t = s / bd.SEGS; // 0=tail, 1=head
      const amp = (1 - t) * this.species.size * 0.12;
      const wave = Math.sin(t * 7 - phase) * amp;
      for (let j = 0; j <= bd.RING; j++) {
        const idx = (s * (bd.RING + 1) + j) * 3;
        positions.array[idx] = bd.rest[idx] + wave;
      }
    }
    positions.needsUpdate = true;
    bd.geo.computeVertexNormals();

    // Tail wag synchronized with body wave
    this.tailMesh.rotation.z = Math.sin(phase) * 0.35;

    // Dorsal fin flutter
    this.dorsalMesh.rotation.z = Math.sin(time * 3 + this.swimPhase) * 0.04;

    // Pectoral fin flutter
    const pFlutter = Math.sin(time * 6 + this.swimPhase) * 0.15;
    this.leftFin.rotation.z = -0.3 + pFlutter;
    this.rightFin.rotation.z = 0.3 - pFlutter;
  }

  destroy() {
    this.alive = false;
    scene.remove(this.mesh);
    this.body.geo.dispose();
    this.mat.dispose();
  }
}

// Boids rules
const _sep = new THREE.Vector3();
const _ali = new THREE.Vector3();
const _coh = new THREE.Vector3();
const _steer = new THREE.Vector3();
const _diff = new THREE.Vector3();

function boids(fish, allFish, dt) {
  const sp = fish.species;
  _sep.set(0, 0, 0);
  _ali.set(0, 0, 0);
  _coh.set(0, 0, 0);
  let sepCount = 0, aliCount = 0, cohCount = 0;

  for (let i = 0; i < allFish.length; i++) {
    const other = allFish[i];
    if (other === fish || !other.alive) continue;
    _diff.subVectors(fish.pos, other.pos);
    const dist = _diff.length();

    // Separation (all species)
    if (dist < sp.separationDist && dist > 0) {
      _diff.normalize().divideScalar(dist);
      _sep.add(_diff);
      sepCount++;
    }

    // Alignment & cohesion (same species only)
    if (other.species === sp && dist < sp.neighborDist) {
      _ali.add(other.vel);
      aliCount++;
      _coh.add(other.pos);
      cohCount++;
    }
  }

  // Apply separation
  if (sepCount > 0) {
    _sep.divideScalar(sepCount).normalize().multiplyScalar(sp.maxSpeed);
    _sep.sub(fish.vel).clampLength(0, sp.maxForce * 1.5);
    fish.applyForce(_sep);
  }

  // Apply alignment
  if (aliCount > 0) {
    _ali.divideScalar(aliCount).normalize().multiplyScalar(sp.maxSpeed);
    _ali.sub(fish.vel).clampLength(0, sp.maxForce);
    fish.applyForce(_ali.multiplyScalar(sp.alignWeight));
  }

  // Apply cohesion
  if (cohCount > 0) {
    _coh.divideScalar(cohCount).sub(fish.pos);
    _coh.normalize().multiplyScalar(sp.maxSpeed);
    _coh.sub(fish.vel).clampLength(0, sp.maxForce);
    fish.applyForce(_coh.multiplyScalar(sp.cohesionWeight));
  }

  // Wall avoidance â€” stay inside the bowl sphere
  const distFromCenter = fish.pos.length();
  if (distFromCenter > BOWL_INNER * 0.7) {
    const pushStrength = Math.pow((distFromCenter - BOWL_INNER * 0.7) / (BOWL_INNER * 0.3), 2);
    _steer.copy(fish.pos).normalize().multiplyScalar(-sp.maxForce * 3 * pushStrength);
    fish.applyForce(_steer);
  }

  // Stay below water, above sand
  if (fish.pos.y > WATER_Y - 0.5) {
    fish.applyForce(new THREE.Vector3(0, -sp.maxForce * 2, 0));
  }
  if (fish.pos.y < SAND_Y + 0.5 + sp.size) {
    fish.applyForce(new THREE.Vector3(0, sp.maxForce * 2, 0));
  }

  // Gentle tendency to stay in mid-water
  const idealY = (SAND_Y + WATER_Y) * 0.5 - 0.5;
  const yDiff = idealY - fish.pos.y;
  fish.applyForce(new THREE.Vector3(0, yDiff * sp.maxForce * 0.1, 0));
}

// Species definitions
const SPECIES = {
  small: {
    name: 'Neon Tetra',
    size: 0.2,
    speed: 1.2,
    maxSpeed: 2.0,
    maxForce: 0.06,
    separationDist: 0.6,
    neighborDist: 2.5,
    alignWeight: 1.0,
    cohesionWeight: 1.0,
    colors: [0x00aaff, 0x0088dd, 0x44ccff, 0x2299ee],
    predators: ['medium', 'large'],
    prey: [],
    schooling: true
  },
  medium: {
    name: 'Angelfish',
    size: 0.4,
    speed: 0.8,
    maxSpeed: 1.5,
    maxForce: 0.04,
    separationDist: 1.0,
    neighborDist: 3.0,
    alignWeight: 0.7,
    cohesionWeight: 0.6,
    colors: [0xffcc44, 0xffaa22, 0xeebb55, 0xffd866],
    predators: ['large'],
    prey: ['small'],
    schooling: true
  },
  large: {
    name: 'Betta',
    size: 0.7,
    speed: 0.5,
    maxSpeed: 1.2,
    maxForce: 0.03,
    separationDist: 1.5,
    neighborDist: 4.0,
    alignWeight: 0.2,
    cohesionWeight: 0.1,
    colors: [0xcc22ff, 0xaa00dd, 0x8833cc, 0xbb44ee],
    predators: [],
    prey: ['small', 'medium'],
    schooling: false
  }
};

// Spawn initial fish
function spawnFish(speciesKey, count) {
  const sp = SPECIES[speciesKey];
  for (let i = 0; i < count; i++) {
    const angle = rng() * Math.PI * 2;
    const r = 1 + rng() * 2;
    const y = SAND_Y + 1.5 + rng() * (WATER_Y - SAND_Y - 3);
    const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
    fishList.push(new Fish(sp, speciesKey, pos));
  }
}

spawnFish('small', 18);
spawnFish('medium', 8);
spawnFish('large', 3);

// ================================================================
// CAMERA CONTROLS
// ================================================================

let camRadius = 13, camPhi = 1.05, camTheta = 0;
let dragging = false, prevMX = 0, prevMY = 0;
const canvas = renderer.domElement;

canvas.addEventListener('mousedown', e => {
  dragging = true; prevMX = e.clientX; prevMY = e.clientY;
});
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  camTheta -= (e.clientX - prevMX) * 0.005;
  camPhi = Math.max(0.3, Math.min(Math.PI * 0.48, camPhi - (e.clientY - prevMY) * 0.005));
  prevMX = e.clientX; prevMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
  camRadius = Math.max(7, Math.min(22, camRadius + e.deltaY * 0.01));
}, { passive: true });

// Touch support
canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    dragging = true;
    prevMX = e.touches[0].clientX;
    prevMY = e.touches[0].clientY;
  }
}, { passive: true });
canvas.addEventListener('touchmove', e => {
  if (!dragging || e.touches.length !== 1) return;
  camTheta -= (e.touches[0].clientX - prevMX) * 0.005;
  camPhi = Math.max(0.3, Math.min(Math.PI * 0.48, camPhi - (e.touches[0].clientY - prevMY) * 0.005));
  prevMX = e.touches[0].clientX; prevMY = e.touches[0].clientY;
}, { passive: true });
canvas.addEventListener('touchend', () => dragging = false);

// ================================================================
// RENDER LOOP
// ================================================================

let lastTime = 0;

function animate(now) {
  requestAnimationFrame(animate);
  const time = now * 0.001;
  const dt = Math.min(time - lastTime, 0.05);
  lastTime = time;
  if (dt <= 0) return;

  // Auto-rotate when not dragging
  if (!dragging) camTheta += 0.04 * dt;

  // Update camera
  camera.position.set(
    camRadius * Math.sin(camPhi) * Math.sin(camTheta),
    camRadius * Math.cos(camPhi),
    camRadius * Math.sin(camPhi) * Math.cos(camTheta)
  );
  camera.lookAt(0, -0.5, 0);

  // Water waves
  waterMat.uniforms.uTime.value = time;

  // Background color shift
  bgMat.uniforms.uTime.value = time;

  // Particle drift
  const pp = particleGeo.attributes.position;
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    let y = pp.getY(i) + particleSpeeds[i] * dt * 60;
    if (y > WATER_Y - 0.3) {
      y = SAND_Y + 0.5;
      const a = Math.random() * Math.PI * 2, r = Math.random() * 3;
      pp.setX(i, Math.cos(a) * r);
      pp.setZ(i, Math.sin(a) * r);
    }
    pp.setY(i, y);
  }
  pp.needsUpdate = true;

  // Seaweed sway
  seaweeds.forEach((sw, idx) => {
    sw.rotation.z = Math.sin(time * 0.5 + idx * 1.5) * 0.08;
    sw.rotation.x = Math.cos(time * 0.3 + idx * 2.0) * 0.05;
  });

  // Fish boids + update
  for (let i = 0; i < fishList.length; i++) {
    if (!fishList[i].alive) continue;
    boids(fishList[i], fishList, dt);
    fishList[i].update(dt, time);
  }

  renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// ================================================================
// RESIZE
// ================================================================

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

</script>
</body>
</html>
