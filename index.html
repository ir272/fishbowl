<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Impossible Fishbowl</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#030912;font-family:'Helvetica Neue',Arial,sans-serif}
canvas{display:block}
#loading{
  position:fixed;top:0;left:0;right:0;bottom:0;
  background:#030912;z-index:1000;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  transition:opacity 1s;
}
#loading h1{
  color:rgba(140,180,230,0.7);font-size:18px;font-weight:300;
  letter-spacing:6px;text-transform:uppercase;margin-bottom:30px;
}
.loader-ring{
  width:60px;height:60px;border-radius:50%;
  border:2px solid rgba(100,140,200,0.1);
  border-top-color:rgba(140,180,230,0.6);
  animation:spin 1.2s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}
#loading p{
  color:rgba(140,170,220,0.3);font-size:11px;
  margin-top:20px;letter-spacing:1px;
}
#hud{
  position:fixed;bottom:24px;left:24px;
  pointer-events:none;user-select:none;z-index:10;
  transition:opacity 0.5s;
}
#hud *{pointer-events:auto}
.hud-panel{
  background:rgba(5,10,25,0.55);
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  border:1px solid rgba(100,140,200,0.15);
  border-radius:12px;padding:14px 18px;
  color:rgba(180,200,230,0.9);font-size:13px;
  letter-spacing:0.3px;min-width:160px;
}
.hud-title{
  font-size:10px;text-transform:uppercase;letter-spacing:1.5px;
  color:rgba(140,170,220,0.6);margin-bottom:10px;
}
.species-row{
  display:flex;align-items:center;gap:8px;
  margin:6px 0;font-variant-numeric:tabular-nums;
}
.species-dot{
  width:8px;height:8px;border-radius:50%;flex-shrink:0;
  box-shadow:0 0 6px currentColor;
}
.species-name{flex:1;font-size:12px}
.species-count{font-size:14px;font-weight:500;min-width:20px;text-align:right}
.hud-day{
  margin-top:10px;padding-top:8px;
  border-top:1px solid rgba(100,140,200,0.1);
  font-size:11px;color:rgba(140,170,220,0.5);
}
#feed-btn{
  display:block;margin-top:10px;
  background:rgba(100,140,200,0.15);border:1px solid rgba(100,140,200,0.25);
  color:rgba(180,200,230,0.8);border-radius:8px;
  padding:8px 16px;font-size:12px;cursor:pointer;
  transition:all 0.2s;letter-spacing:0.5px;width:100%;
}
#feed-btn:hover{background:rgba(100,140,200,0.25);color:#fff}
#feed-btn:active{transform:scale(0.97)}
.hint{
  position:fixed;bottom:24px;right:24px;
  color:rgba(140,170,220,0.3);font-size:11px;
  pointer-events:none;z-index:10;text-align:right;
  line-height:1.6;
}
#event-log{
  position:fixed;top:24px;left:50%;transform:translateX(-50%);
  pointer-events:none;z-index:10;display:flex;flex-direction:column;
  align-items:center;gap:6px;
}
.event-msg{
  background:rgba(5,10,25,0.6);
  backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);
  border:1px solid rgba(100,140,200,0.12);
  border-radius:20px;padding:6px 16px;
  color:rgba(200,215,240,0.85);font-size:12px;
  letter-spacing:0.3px;white-space:nowrap;
  animation:eventFade 4s ease-out forwards;
}
@keyframes eventFade{
  0%{opacity:0;transform:translateY(10px)}
  10%{opacity:1;transform:translateY(0)}
  70%{opacity:1}
  100%{opacity:0;transform:translateY(-5px)}
}
#pause-overlay{
  position:fixed;top:0;left:0;right:0;bottom:0;
  background:rgba(0,0,0,0.3);z-index:20;
  display:none;align-items:center;justify-content:center;
}
#pause-overlay span{
  color:rgba(200,220,255,0.6);font-size:24px;letter-spacing:4px;
  text-transform:uppercase;
}
#fps-counter{
  position:fixed;top:12px;right:12px;
  color:rgba(140,170,220,0.35);font-size:10px;
  pointer-events:none;z-index:10;font-family:monospace;
}
#follow-label{
  position:fixed;bottom:80px;left:50%;transform:translateX(-50%);
  background:rgba(5,10,25,0.55);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);
  border:1px solid rgba(100,140,200,0.15);border-radius:20px;
  padding:6px 16px;color:rgba(200,215,240,0.8);font-size:12px;
  pointer-events:none;z-index:10;display:none;letter-spacing:0.3px;
}
#keyboard-help{
  position:fixed;bottom:24px;right:24px;
  color:rgba(140,170,220,0.25);font-size:10px;
  pointer-events:none;z-index:10;text-align:right;
  line-height:1.7;font-family:monospace;
  opacity:0;transition:opacity 0.5s;
}
#underwater-indicator{
  position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
  color:rgba(100,180,255,0.15);font-size:48px;letter-spacing:8px;
  text-transform:uppercase;pointer-events:none;z-index:10;
  display:none;font-weight:200;
}
#screenshot-flash{
  position:fixed;top:0;left:0;right:0;bottom:0;
  background:white;pointer-events:none;z-index:100;
  opacity:0;transition:opacity 0.15s;
}
.vignette{
  position:fixed;top:0;left:0;right:0;bottom:0;
  pointer-events:none;z-index:1;
  background:radial-gradient(ellipse at center,transparent 55%,rgba(0,2,8,0.5) 100%);
}
</style>
</head>
<body>
<div id="loading"><h1>The Impossible Fishbowl</h1><div class="loader-ring"></div><p>Preparing your aquarium...</p></div>
<div id="hud">
  <div class="hud-panel">
    <div class="hud-title">Population</div>
    <div class="species-row">
      <div class="species-dot" style="color:#22aaff"></div>
      <span class="species-name">Neon Tetra</span>
      <span class="species-count" id="count-small">0</span>
    </div>
    <div class="species-row">
      <div class="species-dot" style="color:#ffbb44"></div>
      <span class="species-name">Angelfish</span>
      <span class="species-count" id="count-medium">0</span>
    </div>
    <div class="species-row">
      <div class="species-dot" style="color:#bb44ee"></div>
      <span class="species-name">Betta</span>
      <span class="species-count" id="count-large">0</span>
    </div>
    <div class="species-row" style="margin-top:8px;padding-top:6px;border-top:1px solid rgba(100,140,200,0.1)">
      <span class="species-name" style="font-size:11px;color:rgba(140,170,220,0.5)">Total</span>
      <span class="species-count" id="count-total" style="color:rgba(180,200,230,0.7)">0</span>
    </div>
    <div class="hud-day" id="day-counter">Day 1</div>
    <div class="hud-day" id="time-of-day" style="border:none;margin-top:4px;padding-top:0"></div>
    <div class="hud-day" id="eco-health" style="border:none;margin-top:2px;padding-top:0"></div>
    <div class="hud-day" id="sim-speed" style="border:none;margin-top:2px;padding-top:0;display:none"></div>
    <button id="feed-btn">Drop Food</button>
  </div>
</div>
<div id="event-log"></div>
<div id="pause-overlay"><span>Paused</span></div>
<div id="fps-counter"></div>
<div id="follow-label"></div>
<div id="underwater-indicator">Dive Mode</div>
<div id="screenshot-flash"></div>
<div id="keyboard-help">Space — Pause&ensp;|&ensp;F — Feed&ensp;|&ensp;+/- — Speed&ensp;|&ensp;T — Time-lapse<br>U — Dive mode&ensp;|&ensp;S — Screenshot&ensp;|&ensp;R — Reset&ensp;|&ensp;Esc — Exit<br>Click fish — Follow&ensp;|&ensp;Double-click — Zoom&ensp;|&ensp;H — Toggle help</div>
<div class="vignette"></div>
<div class="hint">
  Click to feed<br>
  Drag to orbit<br>
  Scroll to zoom
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
'use strict';

// ================================================================
// THE IMPOSSIBLE FISHBOWL
// A mesmerizing real-time 3D aquarium ecosystem
// ================================================================

// --- Seeded RNG for deterministic environment ---
function mkRng(seed) {
  let s = seed;
  return function() { s = (s * 9301 + 49297) % 233280; return s / 233280; };
}
const rng = mkRng(42);

// ================================================================
// RENDERER & SCENE
// ================================================================

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x030912);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);

// ================================================================
// LIGHTING
// ================================================================

scene.add(new THREE.AmbientLight(0x334466, 0.5));

const sunLight = new THREE.DirectionalLight(0xffeedd, 0.9);
sunLight.position.set(3, 10, 5);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(1024, 1024);
Object.assign(sunLight.shadow.camera, { near: 1, far: 25, left: -7, right: 7, top: 7, bottom: -7 });
scene.add(sunLight);

const fillLight = new THREE.PointLight(0x446688, 0.3, 15);
fillLight.position.set(-3, -2, 4);
scene.add(fillLight);

const underwaterGlow = new THREE.PointLight(0x2277aa, 0.4, 10);
underwaterGlow.position.set(0, -2, 0);
scene.add(underwaterGlow);

// ================================================================
// CONSTANTS
// ================================================================

const BOWL_RADIUS = 5;
const BOWL_THETA_START = Math.acos(0.6);        // ~0.927 rad
const BOWL_OPENING_Y = BOWL_RADIUS * 0.6;       // 3.0
const BOWL_OPENING_R = BOWL_RADIUS * Math.sin(BOWL_THETA_START); // 4.0
const WATER_Y = 2.5;
const SAND_Y = -4.0;
const SAND_RADIUS = Math.sqrt(BOWL_RADIUS * BOWL_RADIUS - SAND_Y * SAND_Y) - 0.25; // ~2.75

// ================================================================
// GLASS BOWL
// ================================================================

const bowlGeo = new THREE.SphereGeometry(
  BOWL_RADIUS, 64, 48,
  0, Math.PI * 2,
  BOWL_THETA_START, Math.PI - BOWL_THETA_START
);

const glassMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  side: THREE.DoubleSide,
  uniforms: { uTime: { value: 0 } },
  vertexShader: `
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    void main() {
      vNormal = normalize(mat3(modelMatrix) * normal);
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    varying vec3 vNormal;
    varying vec3 vWorldPos;

    float sparkleHash(vec3 p) {
      return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
    }

    void main() {
      vec3 viewDir = normalize(cameraPosition - vWorldPos);
      vec3 n = gl_FrontFacing ? vNormal : -vNormal;
      float fresnel = pow(1.0 - abs(dot(n, viewDir)), 3.5);

      // Chromatic edge tint
      vec3 baseColor = vec3(0.7, 0.85, 0.95);
      vec3 rainbowEdge = vec3(0.85 + fresnel * 0.1, 0.9, 1.0 - fresnel * 0.05);
      vec3 color = mix(baseColor, rainbowEdge, fresnel);

      // Multiple specular highlights (main + rim)
      vec3 lightDir = normalize(vec3(3.0, 10.0, 5.0));
      vec3 h = normalize(lightDir + viewDir);
      float spec = pow(max(dot(n, h), 0.0), 196.0) * 0.7;
      vec3 lightDir2 = normalize(vec3(-2.0, 6.0, -3.0));
      vec3 h2 = normalize(lightDir2 + viewDir);
      float spec2 = pow(max(dot(n, h2), 0.0), 96.0) * 0.3;
      color += (spec + spec2) * vec3(1.0, 0.98, 0.95);

      // Glass rim glow
      float rimGlow = pow(fresnel, 5.0) * 0.15;
      color += rimGlow * vec3(0.6, 0.8, 1.0);

      // Animated sparkle — tiny moving glints on glass surface
      vec3 sparklePos = floor(vWorldPos * 20.0);
      float sparkle = sparkleHash(sparklePos + floor(uTime * 0.5));
      if (sparkle > 0.995) {
        float glint = pow(sparkle - 0.995, 0.3) * 200.0;
        float sparkleAnim = pow(sin(uTime * 3.0 + sparkleHash(sparklePos) * 6.28) * 0.5 + 0.5, 4.0);
        color += vec3(1.0, 0.98, 0.95) * glint * sparkleAnim * 0.5;
      }

      float alpha = mix(0.03, 0.28, fresnel) + (spec + spec2) * 0.4 + rimGlow;
      gl_FragColor = vec4(color, alpha);
    }
  `
});

const bowlMesh = new THREE.Mesh(bowlGeo, glassMat);
bowlMesh.renderOrder = 10; // Render glass after interior objects for proper transparency
scene.add(bowlMesh);

// Bowl rim
const rimGeo = new THREE.TorusGeometry(BOWL_OPENING_R, 0.1, 12, 64);
const rimMat = new THREE.MeshStandardMaterial({
  color: 0xbbccdd, roughness: 0.05, metalness: 0.2,
  transparent: true, opacity: 0.5
});
const rim = new THREE.Mesh(rimGeo, rimMat);
rim.rotation.x = Math.PI / 2;
rim.position.y = BOWL_OPENING_Y;
scene.add(rim);

// Caustic light pool on surface under bowl
const poolGeo = new THREE.RingGeometry(BOWL_RADIUS - 0.3, BOWL_RADIUS + 1.5, 64, 2);
poolGeo.rotateX(-Math.PI / 2);
const poolMat = new THREE.ShaderMaterial({
  transparent: true, depthWrite: false, side: THREE.DoubleSide,
  uniforms: { uTime: { value: 0 } },
  vertexShader: `
    varying vec2 vUv;
    varying vec3 vWorldPos;
    void main() {
      vUv = uv;
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    varying vec2 vUv;
    varying vec3 vWorldPos;
    void main() {
      float d = length(vWorldPos.xz);
      float ring = smoothstep(0.0, 0.3, vUv.y) * smoothstep(1.0, 0.7, vUv.y);
      float caustic = sin(vWorldPos.x * 4.0 + uTime * 0.5) * cos(vWorldPos.z * 3.5 + uTime * 0.4);
      caustic = pow(abs(caustic), 2.0) * 0.3;
      float alpha = (ring * 0.06 + caustic * ring * 0.08);
      vec3 color = vec3(0.4, 0.6, 0.85) * (0.5 + caustic);
      gl_FragColor = vec4(color, alpha);
    }
  `
});
const lightPool = new THREE.Mesh(poolGeo, poolMat);
lightPool.position.y = SAND_Y - BOWL_RADIUS + 0.5;
scene.add(lightPool);

// ================================================================
// WATER SURFACE
// ================================================================

const waterGeo = new THREE.CircleGeometry(
  Math.sqrt(BOWL_RADIUS * BOWL_RADIUS - WATER_Y * WATER_Y) - 0.15, 64
);
waterGeo.rotateX(-Math.PI / 2);

const waterMat = new THREE.ShaderMaterial({
  transparent: true, depthWrite: false, side: THREE.DoubleSide,
  uniforms: { uTime: { value: 0 } },
  vertexShader: `
    uniform float uTime;
    varying vec2 vUv;
    varying vec3 vWorldPos;
    void main() {
      vUv = uv;
      vec3 pos = position;
      float t = uTime;
      pos.y += sin(pos.x * 2.0 + t * 0.8) * 0.04
             + cos(pos.z * 2.5 + t * 0.6) * 0.03
             + sin(pos.x * 4.0 - pos.z * 3.0 + t * 1.2) * 0.015;
      vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    varying vec2 vUv;
    varying vec3 vWorldPos;
    void main() {
      float d = length(vUv - 0.5) * 2.0;
      // Multi-layer ripple pattern
      float ripple1 = sin(vWorldPos.x * 5.0 + uTime * 0.7) * cos(vWorldPos.z * 4.0 + uTime * 0.5);
      float ripple2 = sin(vWorldPos.x * 8.0 - vWorldPos.z * 6.0 + uTime * 1.1) * 0.5;
      float ripple3 = cos(vWorldPos.x * 3.0 + vWorldPos.z * 7.0 + uTime * 0.4) * 0.3;
      float ripple = (ripple1 + ripple2 + ripple3) * 0.15 + 0.75;

      float alpha = 0.12 * (1.0 - d * 0.3) * ripple;

      // Water color with slight caustic pattern
      vec3 waterColor = mix(vec3(0.15, 0.4, 0.6), vec3(0.3, 0.55, 0.7), ripple);

      // Fresnel-like view angle effect (looking more straight-on = more transparent)
      vec3 viewDir = normalize(cameraPosition - vWorldPos);
      float surfaceFresnel = pow(1.0 - abs(viewDir.y), 2.0);
      alpha = mix(alpha * 0.5, alpha * 1.5, surfaceFresnel);
      waterColor = mix(waterColor, vec3(0.5, 0.7, 0.85), surfaceFresnel * 0.2);

      // Meniscus: bright ring where water meets glass
      float edge = smoothstep(0.82, 0.98, d);
      waterColor += edge * vec3(0.25, 0.35, 0.45);
      alpha += edge * 0.12;

      // Highlight from surface tension
      float tension = smoothstep(0.95, 1.0, d) * 0.15;
      waterColor += tension * vec3(0.8, 0.9, 1.0);

      gl_FragColor = vec4(waterColor, alpha);
    }
  `
});
const waterSurface = new THREE.Mesh(waterGeo, waterMat);
waterSurface.position.y = WATER_Y;
scene.add(waterSurface);

// ================================================================
// SAND FLOOR
// ================================================================

const sandCanvas = document.createElement('canvas');
sandCanvas.width = sandCanvas.height = 512;
const sCtx = sandCanvas.getContext('2d');
sCtx.fillStyle = '#c4a882';
sCtx.fillRect(0, 0, 512, 512);
for (let i = 0; i < 40000; i++) {
  const b = rng() * 30 - 15 | 0;
  sCtx.fillStyle = `rgb(${196 + b},${168 + b},${130 + b})`;
  sCtx.fillRect(rng() * 512, rng() * 512, 1 + rng() * 2, 1 + rng() * 2);
}
const sandTexture = new THREE.CanvasTexture(sandCanvas);
sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping;

const sandGeo = new THREE.CircleGeometry(SAND_RADIUS, 64);
sandGeo.rotateX(-Math.PI / 2);
const sp = sandGeo.attributes.position;
for (let i = 0; i < sp.count; i++) {
  const x = sp.getX(i), z = sp.getZ(i);
  const d = Math.sqrt(x * x + z * z) / SAND_RADIUS;
  sp.setY(i, sp.getY(i) + rng() * 0.12 * (1 - d));
}
sandGeo.computeVertexNormals();

const sandMat = new THREE.ShaderMaterial({
  uniforms: {
    uSandTex: { value: sandTexture },
    uTime: { value: 0 }
  },
  vertexShader: `
    varying vec2 vUv;
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      vUv = uv;
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      vNormal = normalize(mat3(modelMatrix) * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D uSandTex;
    uniform float uTime;
    varying vec2 vUv;
    varying vec3 vWorldPos;
    varying vec3 vNormal;

    // Pseudo-random for Voronoi
    vec2 hash22(vec2 p) {
      p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));
      return fract(sin(p) * 43758.5453);
    }

    // Voronoi-based caustic pattern
    float voronoiCaustic(vec2 p, float t) {
      vec2 ip = floor(p);
      vec2 fp = fract(p);
      float d1 = 8.0, d2 = 8.0;
      for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
          vec2 neighbor = vec2(float(x), float(y));
          vec2 point = hash22(ip + neighbor);
          // Animate the points
          point = 0.5 + 0.5 * sin(t * 0.4 + 6.28 * point);
          float dist = length(neighbor + point - fp);
          if (dist < d1) { d2 = d1; d1 = dist; }
          else if (dist < d2) { d2 = dist; }
        }
      }
      // Edge detection between cells creates caustic lines
      return pow(d2 - d1, 0.8);
    }

    float caustic(vec2 p, float t) {
      // Layer two Voronoi patterns at different scales
      float c1 = voronoiCaustic(p * 1.5, t);
      float c2 = voronoiCaustic(p * 3.0 + 5.0, t * 1.3);
      return (c1 * 0.6 + c2 * 0.4) * 1.2;
    }

    void main() {
      vec3 sand = texture2D(uSandTex, vUv).rgb;
      float caust = caustic(vWorldPos.xz * 0.6, uTime * 0.35);
      vec3 causticColor = vec3(0.35, 0.55, 0.85) * caust * 1.8;
      vec3 lightDir = normalize(vec3(3.0, 10.0, 5.0));
      float diff = max(dot(vNormal, lightDir), 0.0) * 0.5 + 0.5;
      vec3 color = sand * diff + causticColor;
      gl_FragColor = vec4(color, 1.0);
    }
  `
});
const sand = new THREE.Mesh(sandGeo, sandMat);
sand.position.y = SAND_Y;
sand.receiveShadow = true;
scene.add(sand);

// ================================================================
// ROCKS
// ================================================================

function createRock(size, x, z) {
  const geo = new THREE.IcosahedronGeometry(size, 1);
  const p = geo.attributes.position;
  for (let i = 0; i < p.count; i++) {
    const n = 0.7 + rng() * 0.6;
    p.setXYZ(i, p.getX(i) * n, p.getY(i) * (0.5 + rng() * 0.3), p.getZ(i) * n);
  }
  geo.computeVertexNormals();
  const shade = 0.2 + rng() * 0.15;
  const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
    color: new THREE.Color(shade, shade * 0.9, shade * 0.8), roughness: 0.9
  }));
  mesh.position.set(x, SAND_Y + size * 0.3, z);
  mesh.rotation.set(rng() * Math.PI, rng() * Math.PI, rng() * Math.PI);
  mesh.castShadow = mesh.receiveShadow = true;
  scene.add(mesh);
  return mesh;
}

createRock(0.5, -1.5, 1.0);
createRock(0.35, 1.2, 1.5);
createRock(0.45, -0.6, -1.5);
createRock(0.55, 2.0, -0.5);
createRock(0.35, -2.0, -0.3);
createRock(0.3, 0.3, -2.0);

// ================================================================
// CORAL
// ================================================================

const coralPolyps = []; // track for animation

function createCoral(x, z, color, height, branchCount) {
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.55 });

  // Trunk
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry(0.04, 0.12, height, 8), mat
  );
  trunk.position.y = height / 2;
  group.add(trunk);

  // Branches
  for (let i = 0; i < branchCount; i++) {
    const bh = height * (0.3 + rng() * 0.4);
    const branch = new THREE.Mesh(
      new THREE.CylinderGeometry(0.02, 0.06, bh, 6), mat
    );
    const startY = height * (0.3 + rng() * 0.5);
    const angle = rng() * Math.PI * 2;
    const tilt = 0.3 + rng() * 0.5;
    branch.position.set(Math.sin(angle) * 0.15, startY + bh * 0.4, Math.cos(angle) * 0.15);
    branch.rotation.set(tilt * Math.cos(angle), 0, tilt * Math.sin(angle));
    group.add(branch);

    // Animated polyp cluster at tip (replaces simple bulb)
    const tipX = branch.position.x + Math.sin(angle) * bh * 0.3;
    const tipY = startY + bh * 0.8;
    const tipZ = branch.position.z + Math.cos(angle) * bh * 0.3;
    const polypCount = 3 + Math.floor(rng() * 4);
    const polypSeed = rng() * 100;
    const tipColor = new THREE.Color(color).lerp(new THREE.Color(0xffffff), 0.3);

    for (let p = 0; p < polypCount; p++) {
      const pAngle = (p / polypCount) * Math.PI * 2;
      const pLen = 0.06 + rng() * 0.04;
      const pGeo = new THREE.CylinderGeometry(0.005, 0.012, pLen, 4);
      const pMat = new THREE.MeshStandardMaterial({
        color: tipColor, emissive: color, emissiveIntensity: 0.15, roughness: 0.4
      });
      const polyp = new THREE.Mesh(pGeo, pMat);
      polyp.position.set(
        tipX + Math.cos(pAngle) * 0.025,
        tipY,
        tipZ + Math.sin(pAngle) * 0.025
      );
      group.add(polyp);
      coralPolyps.push({ mesh: polyp, seed: polypSeed + p * 1.7, baseAngle: pAngle, baseY: tipY });
    }

    // Central bulb (smaller, glowing)
    const bulbMat = new THREE.MeshStandardMaterial({
      color: tipColor, emissive: color, emissiveIntensity: 0.25, roughness: 0.3
    });
    const bulb = new THREE.Mesh(
      new THREE.SphereGeometry(0.025 + rng() * 0.015, 6, 6), bulbMat
    );
    bulb.position.set(tipX, tipY, tipZ);
    group.add(bulb);
    coralPolyps.push({ mesh: bulb, seed: polypSeed, baseAngle: 0, baseY: tipY, isBulb: true });
  }

  group.position.set(x, SAND_Y + 0.05, z);
  scene.add(group);
  return group;
}

createCoral(1.5, -1.0, 0xff5566, 1.5, 5);
createCoral(-1.2, -1.8, 0xff8844, 1.2, 4);
createCoral(-0.3, 2.0, 0xaa44cc, 1.0, 3);
createCoral(0.8, 1.8, 0xff6699, 0.8, 3);

// Seaweed with vertex shader sway
function createSeaweed(x, z, height, color) {
  const geo = new THREE.PlaneGeometry(0.3, height, 2, 12);
  // Add initial curve
  const p = geo.attributes.position;
  for (let i = 0; i < p.count; i++) {
    const y = p.getY(i);
    const t = (y / height + 0.5); // 0 at base, 1 at tip
    p.setX(i, p.getX(i) + Math.sin(t * 2.5) * 0.12 * t);
    // Taper width toward tip
    if (t > 0.6) p.setX(i, p.getX(i) * (1 - (t - 0.6) * 0.7));
  }
  geo.computeVertexNormals();

  const seedVal = rng() * 10;
  const mat = new THREE.ShaderMaterial({
    side: THREE.DoubleSide, transparent: true,
    uniforms: {
      uTime: { value: 0 },
      uColor: { value: new THREE.Color(color) },
      uSeed: { value: seedVal }
    },
    vertexShader: `
      uniform float uTime;
      uniform float uSeed;
      varying vec2 vUv;
      varying float vHeight;
      void main() {
        vUv = uv;
        vHeight = uv.y;
        vec3 pos = position;
        float t = uv.y; // 0=base, 1=tip
        float sway = sin(uTime * 0.8 + uSeed + t * 3.0) * t * t * 0.3;
        sway += sin(uTime * 1.3 + uSeed * 2.0 + t * 2.0) * t * t * 0.15;
        pos.x += sway;
        pos.z += cos(uTime * 0.6 + uSeed * 1.5 + t * 2.5) * t * t * 0.1;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 uColor;
      varying vec2 vUv;
      varying float vHeight;
      void main() {
        vec3 c = uColor * (0.7 + 0.3 * vHeight);
        // Lighter edges
        float edge = abs(vUv.x - 0.5) * 2.0;
        c += vec3(0.05, 0.1, 0.03) * (1.0 - edge);
        float alpha = 0.85 * (1.0 - smoothstep(0.85, 1.0, vHeight));
        gl_FragColor = vec4(c, alpha);
      }
    `
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, SAND_Y + height * 0.5, z);
  mesh.rotation.y = rng() * Math.PI;
  scene.add(mesh);
  return { mesh, mat };
}

const seaweeds = [];
seaweeds.push(createSeaweed(-1.8, 0.5, 2.2, 0x2d6b3a));
seaweeds.push(createSeaweed(1.6, 0.8, 1.7, 0x3a7d4a));
seaweeds.push(createSeaweed(-0.8, 2.0, 2.0, 0x1f5c2e));
seaweeds.push(createSeaweed(0.5, -2.2, 1.5, 0x2a6e38));
seaweeds.push(createSeaweed(-2.2, -0.8, 1.3, 0x287a3d));
seaweeds.push(createSeaweed(0.0, 2.3, 1.1, 0x348c48));
seaweeds.push(createSeaweed(2.1, -1.2, 1.8, 0x2b7040));

// Sea anemones (gently waving tentacles)
function createAnemone(x, z, color, tentacles, radius) {
  const group = new THREE.Group();
  const baseMat = new THREE.MeshStandardMaterial({ color: 0x884466, roughness: 0.7 });
  const base = new THREE.Mesh(new THREE.CylinderGeometry(radius * 0.3, radius * 0.5, radius * 0.4, 8), baseMat);
  base.position.y = radius * 0.2;
  group.add(base);

  const tentacleMat = new THREE.ShaderMaterial({
    side: THREE.DoubleSide, transparent: true,
    uniforms: { uTime: { value: 0 }, uColor: { value: new THREE.Color(color) } },
    vertexShader: `
      uniform float uTime;
      varying float vH;
      attribute float aSeed;
      void main() {
        vH = uv.y;
        vec3 pos = position;
        float sway = sin(uTime * 0.7 + pos.x * 3.0 + pos.z * 2.0) * vH * vH * 0.2;
        pos.x += sway;
        pos.z += cos(uTime * 0.5 + pos.x * 2.0 + pos.z * 3.0) * vH * vH * 0.15;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 uColor;
      varying float vH;
      void main() {
        vec3 c = uColor * (0.6 + 0.4 * vH);
        // Bright tips
        c = mix(c, vec3(1.0, 0.9, 0.8), smoothstep(0.7, 1.0, vH) * 0.5);
        gl_FragColor = vec4(c, 0.9);
      }
    `
  });

  const tentacleGeos = [];
  for (let i = 0; i < tentacles; i++) {
    const angle = (i / tentacles) * Math.PI * 2 + rng() * 0.3;
    const r = radius * (0.4 + rng() * 0.4);
    const h = radius * (0.6 + rng() * 0.8);
    const geo = new THREE.PlaneGeometry(radius * 0.08, h, 1, 6);
    const mesh = new THREE.Mesh(geo, tentacleMat);
    mesh.position.set(Math.cos(angle) * r, radius * 0.4 + h * 0.5, Math.sin(angle) * r);
    mesh.rotation.y = -angle;
    mesh.rotation.z = (rng() - 0.5) * 0.3;
    group.add(mesh);
  }

  group.position.set(x, SAND_Y + 0.05, z);
  scene.add(group);
  return { group, mat: tentacleMat };
}

const anemones = [];
anemones.push(createAnemone(-1.8, -1.2, 0xff4488, 14, 0.4));
anemones.push(createAnemone(1.0, 2.0, 0xff6633, 10, 0.3));
anemones.push(createAnemone(0.5, -0.8, 0xcc55aa, 12, 0.35));

// Anemone fireflies — tiny glowing particles that orbit anemones at night
const FIREFLY_COUNT = 18;
const fireflyPositions = new Float32Array(FIREFLY_COUNT * 3);
const fireflyData = [];
const anemonePositions = [
  { x: -1.8, z: -1.2 }, { x: 1.0, z: 2.0 }, { x: 0.5, z: -0.8 }
];
for (let i = 0; i < FIREFLY_COUNT; i++) {
  const ap = anemonePositions[i % anemonePositions.length];
  const angle = rng() * Math.PI * 2;
  const r = 0.2 + rng() * 0.5;
  fireflyPositions[i * 3] = ap.x + Math.cos(angle) * r;
  fireflyPositions[i * 3 + 1] = SAND_Y + 0.3 + rng() * 1.0;
  fireflyPositions[i * 3 + 2] = ap.z + Math.sin(angle) * r;
  fireflyData.push({
    centerX: ap.x, centerZ: ap.z,
    orbitR: r, orbitSpeed: 0.3 + rng() * 0.5,
    phase: rng() * Math.PI * 2,
    bobSpeed: 1.0 + rng() * 1.5,
    bobPhase: rng() * Math.PI * 2,
    baseY: SAND_Y + 0.3 + rng() * 1.0
  });
}
const fireflyGeo = new THREE.BufferGeometry();
fireflyGeo.setAttribute('position', new THREE.Float32BufferAttribute(fireflyPositions, 3));

const ffCanvas = document.createElement('canvas');
ffCanvas.width = ffCanvas.height = 32;
const ffCtx = ffCanvas.getContext('2d');
const ffGrad = ffCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
ffGrad.addColorStop(0, 'rgba(120,255,180,0.9)');
ffGrad.addColorStop(0.3, 'rgba(100,255,160,0.5)');
ffGrad.addColorStop(1, 'rgba(60,200,120,0)');
ffCtx.fillStyle = ffGrad;
ffCtx.fillRect(0, 0, 32, 32);
const ffTex = new THREE.CanvasTexture(ffCanvas);

const fireflies = new THREE.Points(fireflyGeo, new THREE.PointsMaterial({
  map: ffTex, size: 0.1, transparent: true, opacity: 0,
  blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true
}));
scene.add(fireflies);

// Starfish on sand
function createStarfish(x, z, color, size) {
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
  const armCount = 5;
  for (let i = 0; i < armCount; i++) {
    const angle = (i / armCount) * Math.PI * 2;
    // Each arm is a tapered box
    const armLen = size * 0.7;
    const armGeo = new THREE.BoxGeometry(size * 0.12, size * 0.04, armLen);
    // Taper: narrow at tip
    const p = armGeo.attributes.position;
    for (let j = 0; j < p.count; j++) {
      const z = p.getZ(j);
      const taper = 1 - (z + armLen / 2) / armLen * 0.7;
      p.setX(j, p.getX(j) * taper);
      p.setY(j, p.getY(j) * taper);
    }
    armGeo.computeVertexNormals();
    const arm = new THREE.Mesh(armGeo, mat);
    arm.position.set(Math.cos(angle) * armLen * 0.45, 0, Math.sin(angle) * armLen * 0.45);
    arm.rotation.y = -angle + Math.PI / 2;
    group.add(arm);
  }
  // Center body
  const center = new THREE.Mesh(new THREE.SphereGeometry(size * 0.12, 8, 6), mat);
  center.scale.y = 0.4;
  group.add(center);

  group.position.set(x, SAND_Y + size * 0.02, z);
  group.rotation.y = rng() * Math.PI * 2;
  scene.add(group);
}

createStarfish(1.5, 1.5, 0xff5533, 0.35);
createStarfish(-0.9, -2.0, 0xdd6644, 0.25);

// Decorative shells scattered on sand
function createShell(x, z, scale) {
  // Spiral shell using torus section
  const group = new THREE.Group();
  const shellMat = new THREE.MeshStandardMaterial({
    color: new THREE.Color(0.85 + rng() * 0.1, 0.75 + rng() * 0.15, 0.65 + rng() * 0.1),
    roughness: 0.4, metalness: 0.1
  });
  // Shell body (half sphere)
  const shellGeo = new THREE.SphereGeometry(scale, 8, 8, 0, Math.PI * 2, 0, Math.PI * 0.6);
  const shell = new THREE.Mesh(shellGeo, shellMat);
  shell.rotation.x = Math.PI;
  group.add(shell);
  // Opening lip
  const lipGeo = new THREE.TorusGeometry(scale * 0.8, scale * 0.06, 6, 12, Math.PI);
  const lip = new THREE.Mesh(lipGeo, shellMat);
  lip.rotation.x = Math.PI * 0.5;
  lip.position.y = -scale * 0.15;
  group.add(lip);

  group.position.set(x, SAND_Y + scale * 0.1, z);
  group.rotation.y = rng() * Math.PI * 2;
  group.rotation.z = (rng() - 0.5) * 0.2;
  group.scale.setScalar(0.8 + rng() * 0.4);
  scene.add(group);
  return group;
}

createShell(0.8, 0.5, 0.12);
createShell(-0.5, 1.2, 0.09);
createShell(1.8, -1.5, 0.11);
createShell(-1.6, 0.0, 0.08);

// Small pebbles scattered on sand
function createPebble(x, z) {
  const size = 0.05 + rng() * 0.08;
  const geo = new THREE.SphereGeometry(size, 5, 4);
  const p = geo.attributes.position;
  for (let i = 0; i < p.count; i++) {
    p.setY(i, p.getY(i) * (0.3 + rng() * 0.3));
    p.setX(i, p.getX(i) * (0.8 + rng() * 0.4));
  }
  geo.computeVertexNormals();
  const shade = 0.35 + rng() * 0.25;
  const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
    color: new THREE.Color(shade, shade * 0.95, shade * 0.85), roughness: 0.85
  }));
  mesh.position.set(x, SAND_Y + size * 0.2, z);
  mesh.rotation.set(rng() * Math.PI, rng() * Math.PI, 0);
  scene.add(mesh);
}

// Scatter 15 pebbles
for (let i = 0; i < 15; i++) {
  const angle = rng() * Math.PI * 2;
  const r = 0.3 + rng() * (SAND_RADIUS - 0.5);
  createPebble(Math.cos(angle) * r, Math.sin(angle) * r);
}

// ================================================================
// TREASURE CHEST
// ================================================================

(function createTreasureChest() {
  const group = new THREE.Group();
  const woodMat = new THREE.MeshStandardMaterial({ color: 0x6b3a1f, roughness: 0.75 });
  const metalMat = new THREE.MeshStandardMaterial({ color: 0xc8a83e, roughness: 0.3, metalness: 0.7 });

  // Chest body (box)
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.25, 0.3), woodMat);
  body.position.y = 0.125;
  group.add(body);

  // Lid (half cylinder)
  const lidGeo = new THREE.CylinderGeometry(0.155, 0.155, 0.45, 12, 1, false, 0, Math.PI);
  const lid = new THREE.Mesh(lidGeo, woodMat);
  lid.rotation.z = Math.PI / 2;
  lid.rotation.y = Math.PI;
  lid.position.set(0, 0.25, 0);
  group.add(lid);

  // Metal bands
  for (const xOff of [-0.15, 0, 0.15]) {
    const band = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.26, 0.32), metalMat);
    band.position.set(xOff, 0.125, 0);
    group.add(band);
    // Band on lid
    const lidBand = new THREE.Mesh(new THREE.TorusGeometry(0.155, 0.01, 4, 12, Math.PI), metalMat);
    lidBand.rotation.x = Math.PI / 2;
    lidBand.rotation.z = Math.PI;
    lidBand.position.set(xOff, 0.25, 0);
    group.add(lidBand);
  }

  // Lock plate
  const lockPlate = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.02), metalMat);
  lockPlate.position.set(0, 0.2, 0.16);
  group.add(lockPlate);
  // Keyhole
  const keyhole = new THREE.Mesh(new THREE.CircleGeometry(0.01, 8), new THREE.MeshBasicMaterial({ color: 0x111111 }));
  keyhole.position.set(0, 0.2, 0.171);
  group.add(keyhole);

  // Gold coins spilling out (small circles)
  const coinMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
  for (let i = 0; i < 6; i++) {
    const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.006, 8), coinMat);
    coin.position.set(
      (rng() - 0.5) * 0.5,
      0.003 + rng() * 0.02,
      0.18 + rng() * 0.12
    );
    coin.rotation.x = Math.PI / 2 + (rng() - 0.5) * 0.5;
    coin.rotation.z = rng() * Math.PI;
    group.add(coin);
  }

  group.position.set(-1.0, SAND_Y + 0.01, 0.6);
  group.rotation.y = 0.3;
  group.scale.setScalar(0.85);
  scene.add(group);
})();

// ================================================================
// SCUBA DIVER FIGURINE
// ================================================================

(function createDiver() {
  const group = new THREE.Group();
  const suitMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });
  const skinMat = new THREE.MeshStandardMaterial({ color: 0xddb896, roughness: 0.8 });
  const tankMat = new THREE.MeshStandardMaterial({ color: 0xcc3333, roughness: 0.4, metalness: 0.3 });
  const maskMat = new THREE.MeshStandardMaterial({ color: 0x44aadd, roughness: 0.1, metalness: 0.5, transparent: true, opacity: 0.7 });

  // Body (cylinder)
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.2, 8), suitMat);
  body.position.y = 0.2;
  group.add(body);

  // Head
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), skinMat);
  head.position.y = 0.35;
  group.add(head);

  // Mask
  const mask = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.035, 0.04), maskMat);
  mask.position.set(0, 0.35, 0.035);
  group.add(mask);

  // Air tank
  const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.15, 6), tankMat);
  tank.position.set(0, 0.22, -0.06);
  group.add(tank);

  // Legs
  for (const side of [-1, 1]) {
    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.02, 0.15, 6), suitMat);
    leg.position.set(side * 0.03, 0.075, 0);
    group.add(leg);
    // Flippers
    const flipper = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.01, 0.1), new THREE.MeshStandardMaterial({ color: 0x222288, roughness: 0.5 }));
    flipper.position.set(side * 0.03, 0.005, 0.03);
    group.add(flipper);
  }

  // Arms
  for (const side of [-1, 1]) {
    const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.012, 0.12, 6), suitMat);
    arm.position.set(side * 0.08, 0.22, 0);
    arm.rotation.z = side * 0.3;
    group.add(arm);
  }

  group.position.set(2.0, SAND_Y + 0.01, -0.3);
  group.rotation.y = -0.5;
  group.scale.setScalar(1.2);
  scene.add(group);
})();

// ================================================================
// AIR STONE (bubble stream source)
// ================================================================

const airStonePos = new THREE.Vector3(-2.0, SAND_Y + 0.05, -0.8);
// Stone base
const airStone = new THREE.Mesh(
  new THREE.CylinderGeometry(0.08, 0.1, 0.06, 8),
  new THREE.MeshStandardMaterial({ color: 0x556677, roughness: 0.9 })
);
airStone.position.copy(airStonePos);
scene.add(airStone);
// Tube running to edge
const tubePoints = [
  new THREE.Vector3(-2.0, SAND_Y + 0.03, -0.8),
  new THREE.Vector3(-2.3, SAND_Y + 0.03, -1.0),
  new THREE.Vector3(-2.5, SAND_Y + 0.05, -1.5),
  new THREE.Vector3(-2.6, SAND_Y + 0.3, -2.2)
];
const tubeCurve = new THREE.CatmullRomCurve3(tubePoints);
const tubeGeo = new THREE.TubeGeometry(tubeCurve, 16, 0.015, 6, false);
const tubeMesh = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({ color: 0x44aa44, roughness: 0.6, transparent: true, opacity: 0.7 }));
scene.add(tubeMesh);

// Air stone bubble stream (separate from main bubbles, focused stream)
const AIR_BUBBLE_COUNT = 15;
const airBubblePositions = new Float32Array(AIR_BUBBLE_COUNT * 3);
const airBubbleSpeeds = new Float32Array(AIR_BUBBLE_COUNT);
const airBubblePhases2 = new Float32Array(AIR_BUBBLE_COUNT);

function resetAirBubble(i) {
  airBubblePositions[i * 3] = airStonePos.x + (Math.random() - 0.5) * 0.06;
  airBubblePositions[i * 3 + 1] = airStonePos.y + 0.05;
  airBubblePositions[i * 3 + 2] = airStonePos.z + (Math.random() - 0.5) * 0.06;
  airBubbleSpeeds[i] = 0.6 + Math.random() * 0.8;
  airBubblePhases2[i] = Math.random() * Math.PI * 2;
}
for (let i = 0; i < AIR_BUBBLE_COUNT; i++) {
  resetAirBubble(i);
  airBubblePositions[i * 3 + 1] = SAND_Y + Math.random() * (WATER_Y - SAND_Y);
}

const airBubbleGeo = new THREE.BufferGeometry();
airBubbleGeo.setAttribute('position', new THREE.BufferAttribute(airBubblePositions, 3));
const airBubbles = new THREE.Points(airBubbleGeo, new THREE.PointsMaterial({
  map: bTex, size: 0.12, transparent: true, opacity: 0.8,
  depthWrite: false, sizeAttenuation: true
}));
scene.add(airBubbles);

// ================================================================
// FLOATING PARTICLES (plankton / debris)
// ================================================================

const pCanvas = document.createElement('canvas');
pCanvas.width = pCanvas.height = 32;
const pCtx = pCanvas.getContext('2d');
const pGrad = pCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
pGrad.addColorStop(0, 'rgba(200,220,255,0.9)');
pGrad.addColorStop(1, 'rgba(200,220,255,0)');
pCtx.fillStyle = pGrad;
pCtx.fillRect(0, 0, 32, 32);
const pTex = new THREE.CanvasTexture(pCanvas);

const PARTICLE_COUNT = 250;
const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
const particleSpeeds = new Float32Array(PARTICLE_COUNT);
for (let i = 0; i < PARTICLE_COUNT; i++) {
  const angle = rng() * Math.PI * 2;
  const r = rng() * 3.0;
  const y = SAND_Y + 0.5 + rng() * (WATER_Y - SAND_Y - 1);
  particlePositions[i * 3] = Math.cos(angle) * r;
  particlePositions[i * 3 + 1] = y;
  particlePositions[i * 3 + 2] = Math.sin(angle) * r;
  particleSpeeds[i] = 0.005 + rng() * 0.01;
}
const particleGeo = new THREE.BufferGeometry();
particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

const particles = new THREE.Points(particleGeo, new THREE.PointsMaterial({
  map: pTex, size: 0.06, transparent: true, opacity: 0.5,
  blending: THREE.AdditiveBlending, depthWrite: false
}));
scene.add(particles);

// ================================================================
// RISING BUBBLES
// ================================================================

const BUBBLE_COUNT = 35;
const bubblePositions = new Float32Array(BUBBLE_COUNT * 3);
const bubbleSpeeds2 = new Float32Array(BUBBLE_COUNT);
const bubblePhases = new Float32Array(BUBBLE_COUNT);
const bubbleLifes = new Float32Array(BUBBLE_COUNT);

function resetBubble(i) {
  const angle = Math.random() * Math.PI * 2;
  const r = 0.3 + Math.random() * 2.2;
  bubblePositions[i * 3] = Math.cos(angle) * r;
  bubblePositions[i * 3 + 1] = SAND_Y + 0.2 + Math.random() * 0.5;
  bubblePositions[i * 3 + 2] = Math.sin(angle) * r;
  bubbleSpeeds2[i] = 0.4 + Math.random() * 0.6;
  bubblePhases[i] = Math.random() * Math.PI * 2;
  bubbleLifes[i] = 5 + Math.random() * 10;
}
for (let i = 0; i < BUBBLE_COUNT; i++) resetBubble(i);

const bubbleGeo = new THREE.BufferGeometry();
bubbleGeo.setAttribute('position', new THREE.BufferAttribute(bubblePositions, 3));

// Bubble texture — hollow ring with highlight
const bCanvas = document.createElement('canvas');
bCanvas.width = bCanvas.height = 64;
const bCtx = bCanvas.getContext('2d');
const bGrad = bCtx.createRadialGradient(32, 32, 18, 32, 32, 30);
bGrad.addColorStop(0, 'rgba(180,220,255,0)');
bGrad.addColorStop(0.6, 'rgba(180,220,255,0)');
bGrad.addColorStop(0.82, 'rgba(200,235,255,0.5)');
bGrad.addColorStop(0.92, 'rgba(220,240,255,0.25)');
bGrad.addColorStop(1, 'rgba(200,230,255,0)');
bCtx.fillStyle = bGrad;
bCtx.fillRect(0, 0, 64, 64);
// Highlight dot (specular)
const hGrad = bCtx.createRadialGradient(22, 20, 0, 22, 20, 7);
hGrad.addColorStop(0, 'rgba(255,255,255,0.9)');
hGrad.addColorStop(1, 'rgba(255,255,255,0)');
bCtx.fillStyle = hGrad;
bCtx.fillRect(0, 0, 64, 64);
const bTex = new THREE.CanvasTexture(bCanvas);

const bubbles = new THREE.Points(bubbleGeo, new THREE.PointsMaterial({
  map: bTex, size: 0.18, transparent: true, opacity: 0.75,
  depthWrite: false, sizeAttenuation: true
}));
scene.add(bubbles);

// ================================================================
// GOD RAYS (volumetric light shafts)
// ================================================================

const godRays = [];

function createGodRay(x, z, width, angle) {
  const height = WATER_Y - SAND_Y - 0.5;
  const geo = new THREE.PlaneGeometry(width, height, 1, 12);
  // Taper: wider at top, narrower at bottom
  const gp = geo.attributes.position;
  for (let i = 0; i < gp.count; i++) {
    const y = gp.getY(i);
    const t = (y + height / 2) / height; // 0=bottom, 1=top
    gp.setX(i, gp.getX(i) * (0.2 + t * 0.8));
  }
  geo.computeVertexNormals();

  const mat = new THREE.ShaderMaterial({
    transparent: true, depthWrite: false, side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending,
    uniforms: { uTime: { value: 0 }, uOffset: { value: Math.random() * 10 }, uIntensity: { value: 1.0 } },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float uTime;
      uniform float uOffset;
      uniform float uIntensity;
      varying vec2 vUv;
      void main() {
        float y = vUv.y;
        float x = abs(vUv.x - 0.5) * 2.0;
        float beam = y * (1.0 - x * x) * 0.07;
        beam *= 0.5 + 0.5 * sin(uTime * 0.2 + uOffset + y * 2.0);
        beam *= 0.7 + 0.3 * sin(uTime * 0.15 + uOffset * 2.0);
        beam *= uIntensity;
        gl_FragColor = vec4(0.45, 0.65, 0.9, beam);
      }
    `
  });

  // Create crossed planes for volume effect
  const group = new THREE.Group();
  const plane1 = new THREE.Mesh(geo, mat);
  group.add(plane1);
  const plane2 = new THREE.Mesh(geo.clone(), mat);
  plane2.rotation.y = Math.PI / 2;
  group.add(plane2);

  group.position.set(x, (WATER_Y + SAND_Y) / 2 + 0.3, z);
  group.rotation.y = angle;
  group.rotation.z = 0.05; // slight tilt
  scene.add(group);
  godRays.push(mat);
  return group;
}

createGodRay(0.8, -0.5, 1.2, 0);
createGodRay(-1.5, 1.0, 0.9, 0.5);
createGodRay(1.2, 1.5, 0.7, -0.3);
createGodRay(-0.5, -1.8, 1.0, 0.8);

// ================================================================
// UNDERWATER ATMOSPHERE (subtle fog volume)
// ================================================================

const atmosGeo = new THREE.SphereGeometry(BOWL_RADIUS - 0.5, 32, 32);
const atmosMat = new THREE.ShaderMaterial({
  transparent: true, depthWrite: false, side: THREE.BackSide,
  uniforms: { uDayPhase: { value: 0 } },
  vertexShader: `
    varying vec3 vWorldPos;
    void main() {
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uDayPhase;
    varying vec3 vWorldPos;
    void main() {
      float depth = 1.0 - (vWorldPos.y + 5.0) / 8.0;
      depth = clamp(depth, 0.0, 1.0);
      // Atmosphere gets denser at night, warmer at dawn/dusk
      float nightMix = 0.0;
      float dawnMix = 0.0;
      if (uDayPhase < 0.15) { dawnMix = 1.0 - uDayPhase / 0.15; nightMix = dawnMix * 0.3; }
      else if (uDayPhase > 0.5 && uDayPhase < 0.65) { dawnMix = (uDayPhase - 0.5) / 0.15; nightMix = dawnMix * 0.3; }
      else if (uDayPhase >= 0.65) { nightMix = 1.0; }
      float alpha = depth * (0.08 + nightMix * 0.06);
      vec3 dayColor = vec3(0.05, 0.1, 0.2);
      vec3 nightColor = vec3(0.02, 0.04, 0.12);
      vec3 dawnColor = vec3(0.12, 0.06, 0.04);
      vec3 color = mix(dayColor, nightColor, nightMix);
      color = mix(color, dawnColor, dawnMix * 0.3);
      gl_FragColor = vec4(color, alpha);
    }
  `
});
scene.add(new THREE.Mesh(atmosGeo, atmosMat));

// ================================================================
// BACKGROUND
// ================================================================

const bgMat = new THREE.ShaderMaterial({
  side: THREE.BackSide, depthWrite: false,
  uniforms: { uTime: { value: 0 }, uDayPhase: { value: 0 } },
  vertexShader: `
    varying vec3 vPos;
    void main() {
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    varying vec3 vPos;

    float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453); }

    float bokeh(vec3 dir, float seed) {
      vec2 uv = dir.xz / (dir.y + 1.0) * 8.0 + seed;
      vec2 id = floor(uv);
      float rnd = hash(id + seed);
      if (rnd < 0.92) return 0.0;
      vec2 center = vec2(hash(id * 1.3 + seed), hash(id * 2.7 + seed * 0.5));
      float d = length(fract(uv) - center);
      float brightness = (rnd - 0.92) * 12.5;
      float twinkle = 0.7 + 0.3 * sin(uTime * (0.5 + rnd * 2.0) + rnd * 6.28);
      return smoothstep(0.12, 0.0, d) * brightness * twinkle;
    }

    uniform float uDayPhase;

    void main() {
      vec3 dir = normalize(vPos);
      float y = dir.y;

      // Day colors
      vec3 dayTop = vec3(0.08, 0.12, 0.22);
      vec3 dayMid = vec3(0.04, 0.07, 0.15);
      vec3 dayBot = vec3(0.02, 0.03, 0.06);

      // Night colors
      vec3 nightTop = vec3(0.01, 0.015, 0.05);
      vec3 nightMid = vec3(0.005, 0.01, 0.03);
      vec3 nightBot = vec3(0.002, 0.005, 0.015);

      // Dusk/dawn accent
      vec3 dawnAccent = vec3(0.15, 0.06, 0.02);

      float nightMix = 0.0;
      float dawnMix = 0.0;
      if (uDayPhase < 0.15) {
        dawnMix = 1.0 - uDayPhase / 0.15;
        nightMix = dawnMix * 0.5;
      } else if (uDayPhase > 0.5 && uDayPhase < 0.65) {
        dawnMix = (uDayPhase - 0.5) / 0.15;
        nightMix = dawnMix * 0.5;
      } else if (uDayPhase >= 0.65) {
        nightMix = 1.0;
      }

      vec3 top = mix(dayTop, nightTop, nightMix);
      vec3 mid = mix(dayMid, nightMid, nightMix);
      vec3 bot = mix(dayBot, nightBot, nightMix);

      vec3 c = mix(bot, mid, smoothstep(-0.5, 0.0, y));
      c = mix(c, top, smoothstep(0.0, 0.5, y));

      // Dawn/dusk warm glow on horizon
      float horizonGlow = exp(-abs(y) * 4.0) * dawnMix * 0.3;
      c += dawnAccent * horizonGlow;

      // Bokeh dots (brighter at night)
      float bokehStrength = 0.5 + nightMix * 1.5;
      float b = bokeh(dir, 0.0) + bokeh(dir, 3.7) * 0.6;
      c += b * vec3(0.15, 0.2, 0.35) * smoothstep(-0.2, 0.3, y) * bokehStrength;

      // Moon glow at night
      if (nightMix > 0.3) {
        vec3 moonDir = normalize(vec3(0.5, 0.7, -0.3));
        float moonDot = max(dot(dir, moonDir), 0.0);
        float moonGlow = pow(moonDot, 64.0) * 0.4 + pow(moonDot, 8.0) * 0.08;
        c += moonGlow * nightMix * vec3(0.6, 0.65, 0.8);
      }

      // Stars at night (tiny bright points in upper hemisphere)
      if (nightMix > 0.3 && y > 0.0) {
        vec2 starUV = dir.xz / (y + 0.5) * 30.0;
        vec2 starID = floor(starUV);
        float starRnd = hash(starID * 3.14);
        if (starRnd > 0.97) {
          vec2 starCenter = vec2(hash(starID * 2.1), hash(starID * 4.3));
          float starD = length(fract(starUV) - starCenter);
          float starBright = smoothstep(0.04, 0.0, starD);
          float twinkle = 0.6 + 0.4 * sin(uTime * (1.0 + starRnd * 3.0) + starRnd * 6.28);
          c += starBright * twinkle * nightMix * vec3(0.8, 0.85, 1.0) * smoothstep(0.0, 0.3, y);
        }
      }

      gl_FragColor = vec4(c, 1.0);
    }
  `
});
const bgSphere = new THREE.Mesh(new THREE.SphereGeometry(45, 16, 16), bgMat);
bgSphere.renderOrder = -100;
scene.add(bgSphere);

// ================================================================
// BOIDS / FISH SYSTEM
// ================================================================

const BOWL_INNER = BOWL_RADIUS - 0.6; // swim boundary
const fishList = [];

// --- Fish body geometry builder (high detail) ---
function buildFishBody(key, size) {
  const SEGS = 16, RING = 10;
  const len = size * 2.6;
  const hs = key === 'medium' ? 1.5 : key === 'large' ? 1.1 : 1.0;
  const pos = [], idx = [];

  for (let s = 0; s <= SEGS; s++) {
    const t = s / SEGS; // 0=tail, 1=head
    const z = (0.5 - t) * len;

    // Species-specific body profile
    let r;
    if (key === 'small') {
      // Tetra: sleek torpedo
      r = Math.sin(t * Math.PI) * 0.33;
      if (t < 0.1) r *= t / 0.1;
      if (t > 0.85) r *= (1 - t) / 0.15;
    } else if (key === 'medium') {
      // Angelfish: diamond shaped, wider in middle
      r = Math.sin(t * Math.PI) * 0.26;
      if (t < 0.08) r *= t / 0.08;
      // Narrower at front
      if (t > 0.7) r *= Math.pow((1 - t) / 0.3, 0.7);
    } else {
      // Betta: robust body, wider head area
      const peak = 0.55; // peak width behind center
      if (t < peak) r = Math.sin((t / peak) * Math.PI * 0.5) * 0.44;
      else r = Math.cos(((t - peak) / (1 - peak)) * Math.PI * 0.5) * 0.44;
      if (t < 0.08) r *= t / 0.08;
    }
    r *= size;

    for (let j = 0; j <= RING; j++) {
      const a = (j / RING) * Math.PI * 2;
      // Flatten belly slightly
      const yScale = Math.sin(a) > 0 ? hs : hs * 0.85;
      pos.push(Math.cos(a) * r, Math.sin(a) * r * yScale, z);
    }
  }

  for (let s = 0; s < SEGS; s++) {
    for (let j = 0; j < RING; j++) {
      const a = s * (RING + 1) + j;
      idx.push(a, a + RING + 1, a + 1, a + 1, a + RING + 1, a + RING + 2);
    }
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
  geo.setIndex(idx);
  geo.computeVertexNormals();
  return { geo, rest: new Float32Array(pos), len, SEGS, RING };
}

// Reusable objects for smooth rotation
const _lookTarget = new THREE.Vector3();
const _lookMat = new THREE.Matrix4();
const _targetQuat = new THREE.Quaternion();
const _up = new THREE.Vector3(0, 1, 0);

class Fish {
  constructor(species, speciesKey, pos) {
    this.species = species;
    this.speciesKey = speciesKey;
    this.pos = pos.clone();
    this.vel = new THREE.Vector3(
      (rng() - 0.5) * 2, (rng() - 0.5) * 0.5, (rng() - 0.5) * 2
    ).normalize().multiplyScalar(species.speed * 0.5);
    this.acc = new THREE.Vector3();
    this.age = 0;
    this.alive = true;
    this.dying = false;
    this.fadeIn = 1.0;
    this.swimPhase = rng() * Math.PI * 2;
    this.opacity = 0;
    this.growthScale = 0.4; // start as baby, grow to 1.0
    this.bankAngle = 0; // body roll when turning
    this.prevVelX = 0; // for turn detection
    this.trickTimer = 0; // countdown for special behavior
    this.trickType = null; // 'spin', 'jump'
    this.trickProgress = 0;

    // Fish personality — individual behavior variation
    this.personality = {
      boldness: 0.6 + rng() * 0.8,    // 0.6-1.4: how close to predators before fleeing
      sociability: 0.7 + rng() * 0.6,  // 0.7-1.3: cohesion/alignment multiplier
      curiosity: 0.5 + rng() * 1.0,    // 0.5-1.5: food attraction strength
      energy: 0.8 + rng() * 0.4,       // 0.8-1.2: base speed multiplier
    };

    const color = species.colors[Math.floor(rng() * species.colors.length)];
    const baseColor = new THREE.Color(color);
    // Iridescent fish shader with depth tinting and caustic dappling
    this.mat = new THREE.ShaderMaterial({
      side: THREE.DoubleSide, transparent: true,
      uniforms: {
        uColor: { value: baseColor },
        uOpacity: { value: 0 },
        uTime: { value: 0 },
        uIridescence: { value: speciesKey === 'small' ? 0.4 : speciesKey === 'large' ? 0.6 : 0.3 },
        uWaterY: { value: WATER_Y },
        uSandY: { value: SAND_Y },
        uSchoolPulse: { value: 0.0 }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vViewDir;
        varying vec2 vUv;
        varying vec3 vWorldPos;
        void main() {
          vUv = uv;
          vNormal = normalize(mat3(modelMatrix) * normal);
          vec4 wp = modelMatrix * vec4(position, 1.0);
          vWorldPos = wp.xyz;
          vViewDir = normalize(cameraPosition - wp.xyz);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform float uOpacity;
        uniform float uTime;
        uniform float uIridescence;
        uniform float uWaterY;
        uniform float uSandY;
        uniform float uSchoolPulse;
        varying vec3 vNormal;
        varying vec3 vViewDir;
        varying vec2 vUv;
        varying vec3 vWorldPos;
        void main() {
          vec3 n = gl_FrontFacing ? vNormal : -vNormal;
          float NdotV = max(dot(n, vViewDir), 0.0);

          // Base diffuse
          vec3 lightDir = normalize(vec3(3.0, 10.0, 5.0));
          float diff = max(dot(n, lightDir), 0.0) * 0.6 + 0.4;

          // Iridescence: hue shift based on view angle
          float iridAngle = pow(1.0 - NdotV, 2.0);
          vec3 iridColor = vec3(
            0.5 + 0.5 * sin(iridAngle * 6.28 + 0.0),
            0.5 + 0.5 * sin(iridAngle * 6.28 + 2.09),
            0.5 + 0.5 * sin(iridAngle * 6.28 + 4.18)
          );

          vec3 color = uColor * diff;
          color = mix(color, iridColor * diff, uIridescence * iridAngle);

          // School pulse — synchronized shimmer when schooling tightly
          float pulse = uSchoolPulse * sin(uTime * 8.0 + vWorldPos.x * 3.0 + vWorldPos.z * 3.0) * 0.15;
          color += pulse * vec3(0.3, 0.5, 1.0);

          // Specular
          vec3 h = normalize(lightDir + vViewDir);
          float spec = pow(max(dot(n, h), 0.0), 32.0) * 0.4;
          color += spec * vec3(1.0, 0.95, 0.9);

          // Rim light
          float rim = pow(1.0 - NdotV, 3.0) * 0.15;
          color += rim * vec3(0.4, 0.6, 0.9);

          // Scale pattern (subtle)
          float scales = sin(vUv.x * 40.0) * sin(vUv.y * 20.0) * 0.03;
          color += scales;

          // Depth-based blue tinting (deeper = bluer)
          float depthRatio = clamp((uWaterY - vWorldPos.y) / (uWaterY - uSandY), 0.0, 1.0);
          vec3 deepTint = vec3(0.15, 0.25, 0.45);
          color = mix(color, deepTint, depthRatio * 0.3);

          // Caustic light dappling on fish body
          float cx = vWorldPos.x * 2.0 + uTime * 0.3;
          float cz = vWorldPos.z * 2.0 + uTime * 0.25;
          float causticDapple = abs(sin(cx + sin(cz * 1.3)) * sin(cz + sin(cx * 0.7)));
          causticDapple = pow(causticDapple, 3.0);
          // Only applies from above (simulating light through water)
          float topLight = max(dot(n, vec3(0.0, 1.0, 0.0)), 0.0);
          color += causticDapple * topLight * vec3(0.2, 0.3, 0.4) * (1.0 - depthRatio);

          gl_FragColor = vec4(color, uOpacity);
        }
      `
    });

    this.mesh = new THREE.Group();

    // Body
    this.body = buildFishBody(speciesKey, species.size);
    this.bodyMesh = new THREE.Mesh(this.body.geo, this.mat);
    this.mesh.add(this.bodyMesh);

    // Tail fin (much larger for Bettas)
    const tMul = speciesKey === 'large' ? 2.0 : speciesKey === 'medium' ? 0.8 : 0.5;
    const tailSegsY = speciesKey === 'large' ? 6 : 4;
    const tailGeo = new THREE.PlaneGeometry(
      species.size * tMul * 0.8,
      species.size * tMul * 1.3,
      1, tailSegsY
    );
    // V-notch: indent center of trailing edge + flowing shape for betta
    const tv = tailGeo.attributes.position;
    for (let i = 0; i < tv.count; i++) {
      const y = tv.getY(i);
      const x = tv.getX(i);
      const indentFactor = 1 - Math.abs(y) / (species.size * tMul * 0.65);
      if (x > 0) tv.setX(i, x - indentFactor * species.size * tMul * 0.15);
      // Betta: fan the tail out wider at the tips
      if (speciesKey === 'large') {
        const fanFactor = Math.abs(y) / (species.size * tMul * 0.65);
        if (x > 0) tv.setX(i, tv.getX(i) + fanFactor * species.size * 0.15);
      }
    }
    tailGeo.computeVertexNormals();
    this.tailMesh = new THREE.Mesh(tailGeo, this.mat);
    this.tailMesh.rotation.y = Math.PI / 2;
    this.tailMesh.position.z = this.body.len * 0.46;
    this.mesh.add(this.tailMesh);

    // Dorsal fin (much taller for Bettas — flowing crown)
    const dh = speciesKey === 'large' ? 0.8 : speciesKey === 'medium' ? 0.5 : 0.22;
    const dorsalSegs = speciesKey === 'large' ? 6 : 4;
    const dorsalGeo = new THREE.PlaneGeometry(this.body.len * (speciesKey === 'large' ? 0.5 : 0.3), species.size * dh, dorsalSegs, 1);
    // Taper dorsal fin toward tail, add flowing curves for betta
    const dv = dorsalGeo.attributes.position;
    for (let i = 0; i < dv.count; i++) {
      const x = dv.getX(i);
      const yt = dv.getY(i);
      if (x > 0) dv.setY(i, yt * (1 - x / (this.body.len * 0.15) * 0.4));
      // Betta: wavy dorsal edge
      if (speciesKey === 'large' && yt > 0) {
        dv.setY(i, dv.getY(i) + Math.sin(x * 12) * species.size * 0.05);
      }
    }
    dorsalGeo.computeVertexNormals();
    this.dorsalMesh = new THREE.Mesh(dorsalGeo, this.mat);
    this.dorsalMesh.rotation.y = Math.PI / 2;
    const bodyR = species.size * (speciesKey === 'small' ? 0.35 : speciesKey === 'medium' ? 0.28 : 0.42);
    const hsFin = speciesKey === 'medium' ? 1.4 : 1.0;
    this.dorsalMesh.position.set(0, bodyR * hsFin + species.size * dh * 0.3, -this.body.len * 0.05);
    this.mesh.add(this.dorsalMesh);

    // Ventral fin (flowing belly fin for Bettas)
    this.ventralMesh = null;
    if (speciesKey === 'large') {
      const vGeo = new THREE.PlaneGeometry(this.body.len * 0.4, species.size * 0.6, 4, 2);
      const vv = vGeo.attributes.position;
      for (let i = 0; i < vv.count; i++) {
        const x = vv.getX(i);
        const y = vv.getY(i);
        if (y < 0) vv.setY(i, y * (1 - Math.abs(x) / (this.body.len * 0.2) * 0.3));
      }
      vGeo.computeVertexNormals();
      this.ventralMesh = new THREE.Mesh(vGeo, this.mat);
      this.ventralMesh.rotation.y = Math.PI / 2;
      this.ventralMesh.position.set(0, -bodyR * 0.85 - species.size * 0.2, this.body.len * 0.05);
      this.mesh.add(this.ventralMesh);
    }

    // Pectoral fins (small side fins)
    const pSize = species.size * (speciesKey === 'large' ? 0.35 : 0.25);
    const pGeo = new THREE.PlaneGeometry(pSize, pSize * 1.5);
    this.leftFin = new THREE.Mesh(pGeo, this.mat);
    this.leftFin.position.set(bodyR * 0.9, -species.size * 0.05, -this.body.len * 0.15);
    this.leftFin.rotation.set(0.2, 0.4, -0.3);
    this.mesh.add(this.leftFin);

    this.rightFin = new THREE.Mesh(pGeo, this.mat);
    this.rightFin.position.set(-bodyR * 0.9, -species.size * 0.05, -this.body.len * 0.15);
    this.rightFin.rotation.set(0.2, -0.4, 0.3);
    this.mesh.add(this.rightFin);

    // Eyes (with night glow capability)
    const eyeGeo = new THREE.SphereGeometry(species.size * 0.06, 6, 6);
    this.eyeMat = new THREE.MeshStandardMaterial({
      color: 0x111122, roughness: 0.1, metalness: 0.5,
      emissive: 0x000000, emissiveIntensity: 0
    });
    const eyeZ = -this.body.len * 0.4;
    const eyeX = species.size * 0.14;
    const eyeY = species.size * 0.06;
    this.mesh.add(Object.assign(new THREE.Mesh(eyeGeo, this.eyeMat), { position: new THREE.Vector3(eyeX, eyeY, eyeZ) }));
    this.mesh.add(Object.assign(new THREE.Mesh(eyeGeo, this.eyeMat), { position: new THREE.Vector3(-eyeX, eyeY, eyeZ) }));

    this.mesh.position.copy(pos);
    scene.add(this.mesh);
  }

  applyForce(f) { this.acc.add(f); }

  update(dt, time) {
    this.vel.add(this.acc);
    const spd = this.vel.length();
    const frenzyBoost = feedingFrenzy > 0 ? 1.3 : 1.0;
    const maxSpd = this.species.maxSpeed * this.personality.energy * frenzyBoost;
    const minSpd = this.species.speed * 0.3 * this.personality.energy;
    if (spd > maxSpd) this.vel.multiplyScalar(maxSpd / spd);
    if (spd < minSpd) this.vel.normalize().multiplyScalar(minSpd);

    this.pos.addScaledVector(this.vel, dt * 60);
    this.acc.set(0, 0, 0);
    this.age += dt;

    this.mesh.position.copy(this.pos);

    // Fade in for newborns
    if (this.fadeIn > 0) {
      this.fadeIn -= dt * 0.8;
      this.opacity = Math.max(0, 1 - this.fadeIn);
    } else if (this.dying) {
      this.opacity -= dt * 0.4;
      this.pos.y -= dt * 0.3;
      if (this.opacity <= 0) { this.destroy(); return; }
    } else {
      this.opacity = Math.min(1, this.opacity + dt * 2);
    }
    this.mat.uniforms.uOpacity.value = Math.max(0, this.opacity);
    this.mat.uniforms.uTime.value = time;

    // Growth: babies grow over time
    if (this.growthScale < 1) {
      this.growthScale = Math.min(1, this.growthScale + dt * 0.015);
      this.mesh.scale.setScalar(this.growthScale);
    }

    // Smooth rotation toward velocity
    if (spd > 0.01) {
      _lookTarget.copy(this.pos).add(this.vel);
      _lookMat.lookAt(this.pos, _lookTarget, _up);
      _targetQuat.setFromRotationMatrix(_lookMat);
      this.mesh.quaternion.slerp(_targetQuat, Math.min(1, dt * 6));
    }

    // Body banking on turns
    const currentVelX = this.vel.x * Math.cos(-this.mesh.rotation.y) - this.vel.z * Math.sin(-this.mesh.rotation.y);
    const turnRate = (currentVelX - this.prevVelX) / Math.max(dt, 0.001);
    this.prevVelX = currentVelX;
    const targetBank = Math.max(-0.4, Math.min(0.4, -turnRate * 0.08));
    this.bankAngle += (targetBank - this.bankAngle) * Math.min(1, dt * 4);
    // Apply bank as local Z rotation on body mesh
    this.bodyMesh.rotation.z = this.bankAngle;

    // Random tricks (very occasional)
    if (!this.trickType && !this.dying && this.growthScale >= 0.8) {
      this.trickTimer -= dt;
      if (this.trickTimer <= 0) {
        this.trickTimer = 30 + Math.random() * 60; // 30-90 seconds between tricks
        // Small chance to do a trick
        if (Math.random() < 0.3) {
          this.trickType = Math.random() < 0.7 ? 'spin' : 'jump';
          this.trickProgress = 0;
        }
      }
    }
    if (this.trickType === 'spin') {
      this.trickProgress += dt * 4;
      this.bodyMesh.rotation.z += Math.sin(this.trickProgress * Math.PI) * Math.PI * 2 * dt * 3;
      if (this.trickProgress >= 1) this.trickType = null;
    }
    if (this.trickType === 'jump' && this.pos.y > WATER_Y - 1.5) {
      this.trickProgress += dt * 2;
      const jumpPhase = Math.sin(this.trickProgress * Math.PI);
      this.pos.y += jumpPhase * dt * 3;
      if (this.trickProgress >= 1) {
        this.trickType = null;
        createSplashRipple(this.pos.x, this.pos.z);
      }
    } else if (this.trickType === 'jump') {
      this.trickType = null; // Too deep to jump
    }

    // Body undulation (sine wave along spine, stronger at tail)
    const bd = this.body;
    const positions = bd.geo.attributes.position;
    const swimFreq = 4 + spd * 2;
    const phase = this.swimPhase + time * swimFreq;

    for (let s = 0; s <= bd.SEGS; s++) {
      const t = s / bd.SEGS; // 0=tail, 1=head
      const amp = (1 - t) * this.species.size * 0.12;
      const wave = Math.sin(t * 7 - phase) * amp;
      for (let j = 0; j <= bd.RING; j++) {
        const idx = (s * (bd.RING + 1) + j) * 3;
        positions.array[idx] = bd.rest[idx] + wave;
      }
    }
    positions.needsUpdate = true;
    bd.geo.computeVertexNormals();

    // Tail wag synchronized with body wave (more dramatic for betta)
    const tailAmp = this.speciesKey === 'large' ? 0.5 : 0.35;
    this.tailMesh.rotation.z = Math.sin(phase) * tailAmp;

    // Dorsal fin flutter (flowing motion for betta)
    const dorsalAmp = this.speciesKey === 'large' ? 0.1 : 0.04;
    this.dorsalMesh.rotation.z = Math.sin(time * 2 + this.swimPhase) * dorsalAmp;
    if (this.speciesKey === 'large') {
      this.dorsalMesh.rotation.x = Math.sin(time * 1.5 + this.swimPhase) * 0.06;
    }

    // Ventral fin animation for betta
    if (this.ventralMesh) {
      this.ventralMesh.rotation.z = Math.sin(time * 1.8 + this.swimPhase + 1) * 0.12;
      this.ventralMesh.rotation.x = Math.sin(time * 1.2 + this.swimPhase) * 0.05;
    }

    // Pectoral fin flutter
    const pFlutter = Math.sin(time * 6 + this.swimPhase) * 0.15;
    this.leftFin.rotation.z = -0.3 + pFlutter;
    this.rightFin.rotation.z = 0.3 - pFlutter;
  }

  destroy() {
    this.alive = false;
    scene.remove(this.mesh);
    this.body.geo.dispose();
    this.mat.dispose();
    // Dispose all child geometries
    this.mesh.traverse(child => {
      if (child.geometry) child.geometry.dispose();
      if (child.material && child.material !== this.mat) child.material.dispose();
    });
  }
}

// Boids rules
const _sep = new THREE.Vector3();
const _ali = new THREE.Vector3();
const _coh = new THREE.Vector3();
const _steer = new THREE.Vector3();
const _diff = new THREE.Vector3();

function boids(fish, allFish, dt) {
  const sp = fish.species;
  _sep.set(0, 0, 0);
  _ali.set(0, 0, 0);
  _coh.set(0, 0, 0);
  let sepCount = 0, aliCount = 0, cohCount = 0;

  for (let i = 0; i < allFish.length; i++) {
    const other = allFish[i];
    if (other === fish || !other.alive) continue;
    _diff.subVectors(fish.pos, other.pos);
    const dist = _diff.length();

    // Separation (all species)
    if (dist < sp.separationDist && dist > 0) {
      _diff.normalize().divideScalar(dist);
      _sep.add(_diff);
      sepCount++;
    }

    // Alignment & cohesion (same species only)
    if (other.species === sp && dist < sp.neighborDist) {
      _ali.add(other.vel);
      aliCount++;
      _coh.add(other.pos);
      cohCount++;
    }
  }

  // Apply separation
  if (sepCount > 0) {
    _sep.divideScalar(sepCount).normalize().multiplyScalar(sp.maxSpeed);
    _sep.sub(fish.vel).clampLength(0, sp.maxForce * 1.5);
    fish.applyForce(_sep);
  }

  // Apply alignment (modulated by sociability)
  if (aliCount > 0) {
    _ali.divideScalar(aliCount).normalize().multiplyScalar(sp.maxSpeed);
    _ali.sub(fish.vel).clampLength(0, sp.maxForce);
    fish.applyForce(_ali.multiplyScalar(sp.alignWeight * fish.personality.sociability));
  }

  // Apply cohesion (modulated by sociability)
  if (cohCount > 0) {
    _coh.divideScalar(cohCount).sub(fish.pos);
    _coh.normalize().multiplyScalar(sp.maxSpeed);
    _coh.sub(fish.vel).clampLength(0, sp.maxForce);
    fish.applyForce(_coh.multiplyScalar(sp.cohesionWeight * fish.personality.sociability));
  }

  // Wall avoidance — stay inside the bowl sphere
  const distFromCenter = fish.pos.length();
  if (distFromCenter > BOWL_INNER * 0.7) {
    const pushStrength = Math.pow((distFromCenter - BOWL_INNER * 0.7) / (BOWL_INNER * 0.3), 2);
    _steer.copy(fish.pos).normalize().multiplyScalar(-sp.maxForce * 3 * pushStrength);
    fish.applyForce(_steer);
  }

  // Stay below water, above sand
  if (fish.pos.y > WATER_Y - 0.5) {
    fish.applyForce(new THREE.Vector3(0, -sp.maxForce * 2, 0));
  }
  if (fish.pos.y < SAND_Y + 0.5 + sp.size) {
    fish.applyForce(new THREE.Vector3(0, sp.maxForce * 2, 0));
  }

  // Gentle tendency to stay in mid-water
  const idealY = (SAND_Y + WATER_Y) * 0.5 - 0.5;
  const yDiff = idealY - fish.pos.y;
  fish.applyForce(new THREE.Vector3(0, yDiff * sp.maxForce * 0.1, 0));

  // Predator avoidance — flee from species that eat us
  if (sp.predators.length > 0) {
    for (let i = 0; i < allFish.length; i++) {
      const other = allFish[i];
      if (other === fish || !other.alive || other.dying) continue;
      if (!sp.predators.includes(other.speciesKey)) continue;
      _diff.subVectors(fish.pos, other.pos);
      const dist = _diff.length();
      if (dist < sp.neighborDist * 1.5 * fish.personality.boldness && dist > 0) {
        _diff.normalize().multiplyScalar(sp.maxForce * 3 / (fish.personality.boldness * Math.max(dist * 0.3, 0.1)));
        fish.applyForce(_diff);
      }
    }
  }

  // Prey chasing — hunt species we eat
  if (sp.prey.length > 0 && !fish.dying) {
    let closestPrey = null, closestDist = Infinity;
    for (let i = 0; i < allFish.length; i++) {
      const other = allFish[i];
      if (other === fish || !other.alive || other.dying) continue;
      if (!sp.prey.includes(other.speciesKey)) continue;
      const dist = fish.pos.distanceTo(other.pos);
      if (dist < closestDist && dist < sp.neighborDist * 2) {
        closestDist = dist;
        closestPrey = other;
      }
    }
    if (closestPrey) {
      _steer.subVectors(closestPrey.pos, fish.pos).normalize().multiplyScalar(sp.maxForce * 1.2);
      fish.applyForce(_steer);
    }
  }

  // Food attraction
  if (foodParticles.length > 0) {
    let closestFood = null, closestFoodDist = Infinity;
    for (const food of foodParticles) {
      if (food.eaten) continue;
      const d = fish.pos.distanceTo(food.pos);
      if (d < closestFoodDist && d < sp.neighborDist * 3) {
        closestFoodDist = d;
        closestFood = food;
      }
    }
    if (closestFood) {
      _steer.subVectors(closestFood.pos, fish.pos).normalize().multiplyScalar(sp.maxForce * 2.5 * fish.personality.curiosity);
      fish.applyForce(_steer);
      if (closestFoodDist < sp.size * 1.5) closestFood.eaten = true;
    }
  }

  // Mouse scatter — flee from mouse near glass
  if (mouseWorldPos) {
    const dist = fish.pos.distanceTo(mouseWorldPos);
    if (dist < 2.5) {
      _steer.subVectors(fish.pos, mouseWorldPos).normalize();
      _steer.multiplyScalar(sp.maxForce * 4 / Math.max(dist * 0.5, 0.3));
      fish.applyForce(_steer);
    }
  }
}

// Species definitions
const SPECIES = {
  small: {
    name: 'Neon Tetra',
    size: 0.2,
    speed: 1.2,
    maxSpeed: 2.0,
    maxForce: 0.06,
    separationDist: 0.6,
    neighborDist: 2.5,
    alignWeight: 1.0,
    cohesionWeight: 1.0,
    colors: [0x00aaff, 0x0088dd, 0x44ccff, 0x2299ee],
    predators: ['medium', 'large'],
    prey: [],
    schooling: true,
    lifespan: 150, maturityAge: 20, reproChance: 0.4, maxPop: 25, minPop: 5
  },
  medium: {
    name: 'Angelfish',
    size: 0.4,
    speed: 0.8,
    maxSpeed: 1.5,
    maxForce: 0.04,
    separationDist: 1.0,
    neighborDist: 3.0,
    alignWeight: 0.7,
    cohesionWeight: 0.6,
    colors: [0xffcc44, 0xffaa22, 0xeebb55, 0xffd866],
    predators: ['large'],
    prey: ['small'],
    schooling: true,
    lifespan: 240, maturityAge: 30, reproChance: 0.25, maxPop: 12, minPop: 3
  },
  large: {
    name: 'Betta',
    size: 0.7,
    speed: 0.5,
    maxSpeed: 1.2,
    maxForce: 0.03,
    separationDist: 1.5,
    neighborDist: 4.0,
    alignWeight: 0.2,
    cohesionWeight: 0.1,
    colors: [0xcc22ff, 0xaa00dd, 0x8833cc, 0xbb44ee],
    predators: [],
    prey: ['small', 'medium'],
    schooling: false,
    lifespan: 400, maturityAge: 50, reproChance: 0.15, maxPop: 5, minPop: 1
  }
};

// Spawn initial fish
function spawnFish(speciesKey, count) {
  const sp = SPECIES[speciesKey];
  for (let i = 0; i < count; i++) {
    const angle = rng() * Math.PI * 2;
    const r = 1 + rng() * 2;
    const y = SAND_Y + 1.5 + rng() * (WATER_Y - SAND_Y - 3);
    const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
    fishList.push(new Fish(sp, speciesKey, pos));
  }
}

spawnFish('small', 18);
spawnFish('medium', 8);
spawnFish('large', 3);

// ================================================================
// ECOSYSTEM — food chain, reproduction, lifespan
// ================================================================

let ecoTimer = 0;
const ECO_TICK = 5; // seconds between ecosystem checks

function countSpecies() {
  const c = { small: 0, medium: 0, large: 0 };
  for (const f of fishList) if (f.alive && !f.dying) c[f.speciesKey]++;
  return c;
}

function checkEating() {
  for (let i = 0; i < fishList.length; i++) {
    const pred = fishList[i];
    if (!pred.alive || pred.dying || pred.species.prey.length === 0) continue;

    for (let j = 0; j < fishList.length; j++) {
      const prey = fishList[j];
      if (!prey.alive || prey.dying || pred === prey) continue;
      if (!pred.species.prey.includes(prey.speciesKey)) continue;

      const dist = pred.pos.distanceTo(prey.pos);
      const eatDist = (pred.species.size + prey.species.size) * 0.6;
      if (dist < eatDist) {
        const counts = countSpecies();
        if (counts[prey.speciesKey] > prey.species.minPop) {
          prey.dying = true;
          prey.opacity = prey.mat.uniforms.uOpacity.value;
          pred.mesh.scale.multiplyScalar(1.01);
          ecoStats.meals++;
          showEvent(`${pred.species.name} caught a ${prey.species.name}`);
        }
      }
    }
  }
}

function updateEcosystem(dt) {
  // Eating happens every frame
  checkEating();

  ecoTimer += dt;
  if (ecoTimer < ECO_TICK) return;
  ecoTimer = 0;

  const counts = countSpecies();

  // Reproduction
  for (const key of ['small', 'medium', 'large']) {
    const sp = SPECIES[key];
    if (counts[key] >= 2 && counts[key] < sp.maxPop && Math.random() < sp.reproChance) {
      const parents = fishList.filter(f => f.alive && !f.dying && f.speciesKey === key && f.age > sp.maturityAge);
      if (parents.length >= 2) {
        const parent = parents[Math.floor(Math.random() * parents.length)];
        const offset = new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.3,
          (Math.random() - 0.5) * 0.5
        );
        const baby = new Fish(sp, key, parent.pos.clone().add(offset));
        fishList.push(baby);
        ecoStats.births++;
        showEvent(`A baby ${sp.name} was born!`);
      }
    }
  }

  // Lifespan — old fish start dying
  for (const f of fishList) {
    if (!f.alive || f.dying) continue;
    if (f.age > f.species.lifespan) {
      const counts2 = countSpecies();
      if (counts2[f.speciesKey] > f.species.minPop) {
        f.dying = true;
        f.opacity = f.mat.uniforms.uOpacity.value;
        ecoStats.deaths++;
        showEvent(`A ${f.species.name} passed away`);
      }
    }
  }

  // Respawn protection: if any species is below minimum, spawn one
  const counts3 = countSpecies();
  for (const key of ['small', 'medium', 'large']) {
    const sp = SPECIES[key];
    if (counts3[key] < sp.minPop) {
      const angle = Math.random() * Math.PI * 2;
      const r = 1 + Math.random() * 2;
      const y = SAND_Y + 1.5 + Math.random() * (WATER_Y - SAND_Y - 3);
      const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
      fishList.push(new Fish(sp, key, pos));
      showEvent(`A wild ${sp.name} appeared!`);
    }
    // Endangered warning
    if (counts3[key] <= sp.minPop + 1 && counts3[key] > 0) {
      showEvent(`${sp.name} population is low!`);
    }
  }

  // Garbage collect dead fish
  for (let i = fishList.length - 1; i >= 0; i--) {
    if (!fishList[i].alive) fishList.splice(i, 1);
  }
}

// ================================================================
// INTERACTION — feeding, mouse scatter
// ================================================================

const raycaster = new THREE.Raycaster();
const mouseNDC = new THREE.Vector2();
const foodParticles = [];
let mouseWorldPos = null;
let mouseScreenX = innerWidth / 2, mouseScreenY = innerHeight / 2;

// Splash ripples on water surface
const splashRipples = [];
function createSplashRipple(x, z) {
  const geo = new THREE.RingGeometry(0.01, 0.05, 32);
  geo.rotateX(-Math.PI / 2);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xaaccff, transparent: true, opacity: 0.6,
    depthWrite: false, side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, WATER_Y + 0.01, z);
  scene.add(mesh);
  splashRipples.push({ mesh, mat, age: 0, maxAge: 1.5 });
}

function updateSplashRipples(dt) {
  for (let i = splashRipples.length - 1; i >= 0; i--) {
    const r = splashRipples[i];
    r.age += dt;
    const t = r.age / r.maxAge;
    const scale = 1 + t * 25;
    r.mesh.scale.set(scale, 1, scale);
    r.mat.opacity = 0.5 * (1 - t * t);
    if (r.age >= r.maxAge) {
      scene.remove(r.mesh);
      r.mesh.geometry.dispose();
      r.mat.dispose();
      splashRipples.splice(i, 1);
    }
  }
}

// Sand disturbance particles — puffs of sand when fish swim near bottom
const sandPuffs = [];
const SAND_PUFF_THRESHOLD = SAND_Y + 0.6; // fish must be this close to sand

function createSandPuff(x, z) {
  const count = 3 + Math.floor(Math.random() * 3);
  for (let i = 0; i < count; i++) {
    const geo = new THREE.SphereGeometry(0.03 + Math.random() * 0.03, 4, 4);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xc8b080, transparent: true, opacity: 0.6,
      roughness: 1.0, emissive: 0x664422, emissiveIntensity: 0.15
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(
      x + (Math.random() - 0.5) * 0.15,
      SAND_Y + 0.05 + Math.random() * 0.05,
      z + (Math.random() - 0.5) * 0.15
    );
    scene.add(mesh);
    sandPuffs.push({
      mesh, mat,
      vel: new THREE.Vector3(
        (Math.random() - 0.5) * 0.3,
        0.15 + Math.random() * 0.25,
        (Math.random() - 0.5) * 0.3
      ),
      life: 1.0 + Math.random() * 0.5,
      maxLife: 1.0 + Math.random() * 0.5
    });
  }
}

function updateSandPuffs(dt) {
  for (let i = sandPuffs.length - 1; i >= 0; i--) {
    const p = sandPuffs[i];
    p.life -= dt;
    p.mesh.position.addScaledVector(p.vel, dt);
    p.vel.y -= dt * 0.3; // gravity
    p.vel.multiplyScalar(0.97); // drag
    const t = 1 - p.life / p.maxLife;
    p.mat.opacity = 0.6 * (1 - t * t);
    p.mesh.scale.setScalar(1 + t * 1.5);
    if (p.life <= 0) {
      scene.remove(p.mesh);
      p.mesh.geometry.dispose();
      p.mat.dispose();
      sandPuffs.splice(i, 1);
    }
  }
}

// Fish swim trails — faint particle trails behind fast-swimming fish
const TRAIL_POOL_SIZE = 80;
const trailPositions = new Float32Array(TRAIL_POOL_SIZE * 3);
const trailOpacities = new Float32Array(TRAIL_POOL_SIZE);
const trailAges = new Float32Array(TRAIL_POOL_SIZE);
let trailIndex = 0;
for (let i = 0; i < TRAIL_POOL_SIZE; i++) {
  trailPositions[i * 3 + 1] = -100; // hide below scene
  trailOpacities[i] = 0;
  trailAges[i] = 999;
}
const trailGeo = new THREE.BufferGeometry();
trailGeo.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));

// Trail texture — soft glow dot
const trCanvas = document.createElement('canvas');
trCanvas.width = trCanvas.height = 32;
const trCtx = trCanvas.getContext('2d');
const trGrad = trCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
trGrad.addColorStop(0, 'rgba(180,210,255,0.6)');
trGrad.addColorStop(0.5, 'rgba(160,200,240,0.2)');
trGrad.addColorStop(1, 'rgba(140,180,220,0)');
trCtx.fillStyle = trGrad;
trCtx.fillRect(0, 0, 32, 32);
const trTex = new THREE.CanvasTexture(trCanvas);

const trailPoints = new THREE.Points(trailGeo, new THREE.PointsMaterial({
  map: trTex, size: 0.08, transparent: true, opacity: 0.4,
  depthWrite: false, sizeAttenuation: true, blending: THREE.AdditiveBlending
}));
scene.add(trailPoints);

function emitTrail(pos) {
  const idx = trailIndex % TRAIL_POOL_SIZE;
  trailPositions[idx * 3] = pos.x + (Math.random() - 0.5) * 0.05;
  trailPositions[idx * 3 + 1] = pos.y + (Math.random() - 0.5) * 0.05;
  trailPositions[idx * 3 + 2] = pos.z + (Math.random() - 0.5) * 0.05;
  trailAges[idx] = 0;
  trailIndex++;
}

function updateTrails(dt) {
  for (let i = 0; i < TRAIL_POOL_SIZE; i++) {
    trailAges[i] += dt;
    if (trailAges[i] > 1.5) {
      trailPositions[i * 3 + 1] = -100; // hide
    } else {
      // Drift upward slightly
      trailPositions[i * 3 + 1] += dt * 0.05;
    }
  }
  trailGeo.attributes.position.needsUpdate = true;
  // Fade overall based on trail age
  trailPoints.material.opacity = 0.35;
}

// Feeding frenzy — temporarily boost nearby fish excitement
let feedingFrenzy = 0;

function dropFood(worldPos) {
  const count = 3 + Math.floor(Math.random() * 3);
  feedingFrenzy = 3.0; // 3 seconds of excitement
  ecoStats.foodDropped++;
  // Splash ripple at impact point
  createSplashRipple(worldPos.x, worldPos.z);
  if (Math.random() > 0.3) createSplashRipple(worldPos.x + (Math.random() - 0.5) * 0.3, worldPos.z + (Math.random() - 0.5) * 0.3);
  for (let i = 0; i < count; i++) {
    const geo = new THREE.SphereGeometry(0.04, 6, 6);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xffbb55, emissive: 0x553311, emissiveIntensity: 0.5, roughness: 0.3
    });
    const mesh = new THREE.Mesh(geo, mat);
    const offset = new THREE.Vector3(
      (Math.random() - 0.5) * 0.4, 0, (Math.random() - 0.5) * 0.4
    );
    mesh.position.copy(worldPos).add(offset);
    scene.add(mesh);
    foodParticles.push({
      mesh,
      pos: mesh.position.clone(),
      vel: new THREE.Vector3((Math.random() - 0.5) * 0.1, -0.4, (Math.random() - 0.5) * 0.1),
      life: 20,
      eaten: false
    });
  }
}

function updateFood(dt) {
  for (let i = foodParticles.length - 1; i >= 0; i--) {
    const f = foodParticles[i];
    f.life -= dt;
    f.pos.addScaledVector(f.vel, dt);
    f.vel.y *= 0.98;
    // Wobble as it sinks
    if (f.vel.y < -0.01) {
      f.vel.x += Math.sin(f.life * 3) * 0.001;
      f.vel.z += Math.cos(f.life * 2.5) * 0.001;
    }
    if (f.pos.y < SAND_Y + 0.1) { f.pos.y = SAND_Y + 0.1; f.vel.set(0, 0, 0); }
    f.mesh.position.copy(f.pos);
    f.mesh.rotation.y += dt * 2; // Gentle spin
    // Fade out near end of life
    if (f.life < 3) f.mesh.material.opacity = f.life / 3;
    if (f.life <= 0 || f.eaten) {
      scene.remove(f.mesh);
      f.mesh.geometry.dispose();
      f.mesh.material.dispose();
      foodParticles.splice(i, 1);
    }
  }
}

function handleClick(e) {
  mouseNDC.set(
    (e.clientX / innerWidth) * 2 - 1,
    -(e.clientY / innerHeight) * 2 + 1
  );
  raycaster.setFromCamera(mouseNDC, camera);
  const waterPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -WATER_Y);
  const hit = new THREE.Vector3();
  raycaster.ray.intersectPlane(waterPlane, hit);
  if (hit) {
    const dist = Math.sqrt(hit.x * hit.x + hit.z * hit.z);
    const maxR = Math.sqrt(BOWL_RADIUS * BOWL_RADIUS - WATER_Y * WATER_Y) - 0.3;
    if (dist < maxR) dropFood(hit);
  }
}

function updateMouseScatter() {
  mouseNDC.set(
    (mouseScreenX / innerWidth) * 2 - 1,
    -(mouseScreenY / innerHeight) * 2 + 1
  );
  raycaster.setFromCamera(mouseNDC, camera);
  // Intersect ray with bowl sphere
  const o = raycaster.ray.origin, d = raycaster.ray.direction;
  const a = d.dot(d), b = 2 * o.dot(d), c = o.dot(o) - BOWL_RADIUS * BOWL_RADIUS;
  const disc = b * b - 4 * a * c;
  if (disc >= 0) {
    const t = (-b - Math.sqrt(disc)) / (2 * a);
    if (t > 0) { mouseWorldPos = o.clone().addScaledVector(d, t); return; }
  }
  mouseWorldPos = null;
}

// ================================================================
// CAMERA CONTROLS
// ================================================================

let camRadius = 13, camRadiusTarget = 13, camPhi = 1.05, camTheta = 0;
let dragging = false, prevMX = 0, prevMY = 0;
let clickStartX = 0, clickStartY = 0;
const canvas = renderer.domElement;

canvas.addEventListener('mousedown', e => {
  dragging = true; prevMX = e.clientX; prevMY = e.clientY;
  clickStartX = e.clientX; clickStartY = e.clientY;
});
canvas.addEventListener('mousemove', e => {
  mouseScreenX = e.clientX;
  mouseScreenY = e.clientY;
  if (!dragging) return;
  camTheta -= (e.clientX - prevMX) * 0.005;
  camPhi = Math.max(0.3, Math.min(Math.PI * 0.48, camPhi - (e.clientY - prevMY) * 0.005));
  prevMX = e.clientX; prevMY = e.clientY;
});
let lastClickTime = 0;
canvas.addEventListener('mouseup', e => {
  dragging = false;
  const dx = e.clientX - clickStartX, dy = e.clientY - clickStartY;
  if (dx * dx + dy * dy < 25) {
    const now = performance.now();
    if (now - lastClickTime < 350) {
      // Double-click: zoom in/out toggle
      camRadiusTarget = camRadiusTarget < 10 ? 13 : 8;
      lastClickTime = 0;
    } else {
      // Single click: try to select fish, otherwise drop food
      if (!trySelectFish(e)) handleClick(e);
      lastClickTime = now;
    }
  }
});
canvas.addEventListener('mouseleave', () => { dragging = false; mouseWorldPos = null; });
canvas.addEventListener('wheel', e => {
  camRadiusTarget = Math.max(7, Math.min(22, camRadiusTarget + e.deltaY * 0.01));
}, { passive: true });

// Touch support
canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    dragging = true;
    prevMX = e.touches[0].clientX; prevMY = e.touches[0].clientY;
    clickStartX = prevMX; clickStartY = prevMY;
  }
}, { passive: true });
canvas.addEventListener('touchmove', e => {
  if (!dragging || e.touches.length !== 1) return;
  camTheta -= (e.touches[0].clientX - prevMX) * 0.005;
  camPhi = Math.max(0.3, Math.min(Math.PI * 0.48, camPhi - (e.touches[0].clientY - prevMY) * 0.005));
  prevMX = e.touches[0].clientX; prevMY = e.touches[0].clientY;
}, { passive: true });
canvas.addEventListener('touchend', e => {
  dragging = false;
  const dx = prevMX - clickStartX, dy = prevMY - clickStartY;
  if (dx * dx + dy * dy < 25) handleClick({ clientX: prevMX, clientY: prevMY });
});

// ================================================================
// HUD
// ================================================================

const hudSmall = document.getElementById('count-small');
const hudMedium = document.getElementById('count-medium');
const hudLarge = document.getElementById('count-large');
const hudDay = document.getElementById('day-counter');
let hudTimer = 0;
let dayCount = 0;
let dayAccum = 0;

const hudTimeOfDay = document.getElementById('time-of-day');

function getTimeOfDayLabel(phase) {
  if (phase < 0.08) return 'Dawn';
  if (phase < 0.15) return 'Sunrise';
  if (phase < 0.3) return 'Morning';
  if (phase < 0.45) return 'Midday';
  if (phase < 0.5) return 'Afternoon';
  if (phase < 0.58) return 'Sunset';
  if (phase < 0.65) return 'Dusk';
  if (phase < 0.82) return 'Night';
  return 'Late Night';
}

const hudTotal = document.getElementById('count-total');
const hudEcoHealth = document.getElementById('eco-health');

function getEcoHealth(counts) {
  // Health based on biodiversity and population levels
  let score = 0;
  for (const key of ['small', 'medium', 'large']) {
    const sp = SPECIES[key];
    const ratio = counts[key] / sp.maxPop;
    if (ratio >= 0.3 && ratio <= 0.9) score += 33;
    else if (ratio > 0) score += 15;
  }
  score = Math.min(100, score);
  if (score >= 80) return { label: 'Thriving', color: 'rgba(80,220,120,0.7)' };
  if (score >= 50) return { label: 'Balanced', color: 'rgba(180,200,100,0.7)' };
  if (score >= 25) return { label: 'Stressed', color: 'rgba(220,160,60,0.7)' };
  return { label: 'Critical', color: 'rgba(220,80,60,0.7)' };
}

function updateHUD(dt, time) {
  hudTimer += dt;
  if (hudTimer < 0.5) return;
  hudTimer = 0;
  const c = countSpecies();
  hudSmall.textContent = c.small;
  hudMedium.textContent = c.medium;
  hudLarge.textContent = c.large;
  hudTotal.textContent = c.small + c.medium + c.large;
  const phase = getDayPhase(time);
  hudTimeOfDay.textContent = getTimeOfDayLabel(phase);
  const eco = getEcoHealth(c);
  hudEcoHealth.textContent = eco.label;
  hudEcoHealth.style.color = eco.color;
}

function updateDay(dt) {
  dayAccum += dt;
  if (dayAccum >= 60) { // 1 minute = 1 day
    dayAccum -= 60;
    dayCount++;
    hudDay.textContent = 'Day ' + (dayCount + 1);
  }
}

// Feed button (for mobile)
document.getElementById('feed-btn').addEventListener('click', e => {
  e.stopPropagation();
  // Drop food at a random position near center of bowl
  const angle = Math.random() * Math.PI * 2;
  const r = Math.random() * 1.5;
  const pos = new THREE.Vector3(Math.cos(angle) * r, WATER_Y, Math.sin(angle) * r);
  dropFood(pos);
});

// Auto-feed: periodically drop food to keep fish fed
let autoFeedTimer = 0;
const AUTO_FEED_INTERVAL = 45; // seconds between auto-feeds

// ================================================================
// EVENT NOTIFICATIONS
// ================================================================

const eventLog = document.getElementById('event-log');
let eventCount = 0;

// Ecosystem statistics
const ecoStats = { births: 0, deaths: 0, meals: 0, foodDropped: 0 };

function showEvent(msg) {
  const el = document.createElement('div');
  el.className = 'event-msg';
  el.textContent = msg;
  eventLog.appendChild(el);
  eventCount++;
  // Remove after animation
  setTimeout(() => { el.remove(); }, 4000);
  // Keep max 4 events visible
  while (eventLog.children.length > 4) eventLog.firstChild.remove();
}

// ================================================================
// FISH FOLLOW / CLICK-TO-SELECT
// ================================================================

let followedFish = null;
const followLabel = document.getElementById('follow-label');

function trySelectFish(e) {
  mouseNDC.set(
    (e.clientX / innerWidth) * 2 - 1,
    -(e.clientY / innerHeight) * 2 + 1
  );
  raycaster.setFromCamera(mouseNDC, camera);
  let closest = null, closestDist = Infinity;
  for (const f of fishList) {
    if (!f.alive || f.dying) continue;
    const d = raycaster.ray.distanceToPoint(f.pos);
    const camDist = camera.position.distanceTo(f.pos);
    // Scale threshold by distance so far fish are still clickable
    if (d < f.species.size * 2.5 && camDist < closestDist) {
      closestDist = camDist;
      closest = f;
    }
  }
  if (closest) {
    followedFish = closest;
    followLabel.textContent = 'Following ' + closest.species.name + '  (Esc to stop)';
    followLabel.style.display = 'block';
    return true;
  }
  return false;
}

function stopFollowing() {
  followedFish = null;
  followLabel.style.display = 'none';
}

// ================================================================
// KEYBOARD SHORTCUTS + PAUSE
// ================================================================

let paused = false;
let simSpeed = 1;
let zenMode = false;
let cinemaMode = false;
let prevSimSpeed = 1;
const pauseOverlay = document.getElementById('pause-overlay');
const keyboardHelp = document.getElementById('keyboard-help');
let helpVisible = false;

document.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  if (key === ' ' || key === 'p') {
    e.preventDefault();
    paused = !paused;
    pauseOverlay.style.display = paused ? 'flex' : 'none';
  }
  if (key === 'f') {
    const angle = Math.random() * Math.PI * 2;
    const r = Math.random() * 1.5;
    dropFood(new THREE.Vector3(Math.cos(angle) * r, WATER_Y, Math.sin(angle) * r));
  }
  if (key === '=' || key === '+') { simSpeed = Math.min(8, simSpeed + 0.5); updateSpeedHUD(); }
  if (key === '-') { simSpeed = Math.max(0.25, simSpeed - 0.25); updateSpeedHUD(); }
  if (key === 'r') { camRadius = 13; camRadiusTarget = 13; camPhi = 1.05; camTheta = 0; stopFollowing(); underwaterMode = false; underwaterIndicator.style.display = 'none'; }
  if (key === 'escape') { stopFollowing(); if (underwaterMode) { underwaterMode = false; underwaterIndicator.style.display = 'none'; camRadiusTarget = 13; } }
  if (key === 'h') { helpVisible = !helpVisible; keyboardHelp.style.opacity = helpVisible ? '1' : '0'; }
  if (key === 'u') toggleUnderwaterMode();
  if (key === 's') takeScreenshot();
  if (key === 't') {
    if (simSpeed < 5) { simSpeed = 8; showEvent('Time-lapse mode: 8x'); }
    else { simSpeed = 1; showEvent('Normal speed'); }
    updateSpeedHUD();
  }
  if (key === 'm') {
    cinemaMode = !cinemaMode;
    if (cinemaMode) { prevSimSpeed = simSpeed; simSpeed = 0.25; showEvent('Cinema mode'); }
    else { simSpeed = prevSimSpeed || 1; showEvent('Normal mode'); }
    updateSpeedHUD();
  }
  if (key === 'i') {
    const c = countSpecies();
    const total = c.small + c.medium + c.large;
    showEvent(`Day ${dayCount + 1} | Pop: ${total} | Births: ${ecoStats.births} | Deaths: ${ecoStats.deaths} | Meals: ${ecoStats.meals}`);
  }
  if (key === 'z') {
    zenMode = !zenMode;
    document.getElementById('hud').style.opacity = zenMode ? '0' : '1';
    document.getElementById('hud').style.pointerEvents = zenMode ? 'none' : 'auto';
    fpsEl.style.display = zenMode ? 'none' : 'block';
    if (zenMode) showEvent('Zen mode — press Z to restore HUD');
  }
});

const simSpeedEl = document.getElementById('sim-speed');
function updateSpeedHUD() {
  if (simSpeed === 1) {
    simSpeedEl.style.display = 'none';
  } else {
    simSpeedEl.style.display = 'block';
    simSpeedEl.textContent = 'Speed: ' + simSpeed.toFixed(1) + 'x';
  }
}

// ================================================================
// UNDERWATER / DIVE MODE
// ================================================================

let underwaterMode = false;
const underwaterIndicator = document.getElementById('underwater-indicator');

function toggleUnderwaterMode() {
  underwaterMode = !underwaterMode;
  underwaterIndicator.style.display = underwaterMode ? 'block' : 'none';
  if (underwaterMode) {
    camRadiusTarget = 3;
    camPhi = Math.PI / 2; // eye-level
    stopFollowing();
    showEvent('Entering dive mode...');
    // Fade out indicator
    setTimeout(() => { underwaterIndicator.style.display = 'none'; }, 2000);
  } else {
    camRadiusTarget = 13;
    showEvent('Exiting dive mode');
  }
}

// ================================================================
// SCREENSHOT
// ================================================================

const screenshotFlash = document.getElementById('screenshot-flash');

function takeScreenshot() {
  // Flash effect
  screenshotFlash.style.transition = 'none';
  screenshotFlash.style.opacity = '0.7';
  requestAnimationFrame(() => {
    screenshotFlash.style.transition = 'opacity 0.4s ease-out';
    screenshotFlash.style.opacity = '0';
  });
  // Capture canvas
  renderer.render(scene, camera);
  const dataURL = renderer.domElement.toDataURL('image/png');
  const link = document.createElement('a');
  link.download = 'fishbowl-' + Date.now() + '.png';
  link.href = dataURL;
  link.click();
  showEvent('Screenshot saved!');
}

// ================================================================
// FPS COUNTER
// ================================================================

const fpsEl = document.getElementById('fps-counter');
let fpsFrames = 0, fpsTime = 0;
function updateFPS(dt) {
  fpsFrames++;
  fpsTime += dt;
  if (fpsTime >= 0.5) {
    fpsEl.textContent = Math.round(fpsFrames / fpsTime) + ' fps';
    fpsFrames = 0;
    fpsTime = 0;
  }
}

// Fade out hint after 8 seconds
const hintEl = document.querySelector('.hint');
setTimeout(() => {
  hintEl.style.transition = 'opacity 2s';
  hintEl.style.opacity = '0';
  setTimeout(() => hintEl.remove(), 2000);
}, 8000);

// ================================================================
// DAY/NIGHT CYCLE
// ================================================================

// One full cycle = 4 minutes (dawn -> day -> dusk -> night -> dawn)
const DAY_CYCLE_DURATION = 240; // seconds

function getDayPhase(time) {
  const t = (time % DAY_CYCLE_DURATION) / DAY_CYCLE_DURATION; // 0-1
  // 0-0.15 dawn, 0.15-0.5 day, 0.5-0.65 dusk, 0.65-1.0 night
  return t;
}

function getDayLighting(phase) {
  let sunIntensity, sunColor, ambientIntensity, ambientColor, exposure;

  if (phase < 0.15) {
    // Dawn: warm orange sunrise
    const t = phase / 0.15;
    sunIntensity = 0.3 + t * 0.7;
    sunColor = new THREE.Color().lerpColors(
      new THREE.Color(0.4, 0.2, 0.1), new THREE.Color(1.0, 0.85, 0.7), t
    );
    ambientIntensity = 0.2 + t * 0.3;
    ambientColor = new THREE.Color().lerpColors(
      new THREE.Color(0.15, 0.1, 0.2), new THREE.Color(0.2, 0.25, 0.35), t
    );
    exposure = 0.8 + t * 0.5;
  } else if (phase < 0.5) {
    // Day: bright, slightly warm
    const t = (phase - 0.15) / 0.35;
    sunIntensity = 1.0;
    sunColor = new THREE.Color(1.0, 0.93, 0.85);
    ambientIntensity = 0.5;
    ambientColor = new THREE.Color(0.2, 0.27, 0.4);
    exposure = 1.3 - Math.sin(t * Math.PI) * 0.1; // slight noon peak
  } else if (phase < 0.65) {
    // Dusk: golden/purple
    const t = (phase - 0.5) / 0.15;
    sunIntensity = 1.0 - t * 0.7;
    sunColor = new THREE.Color().lerpColors(
      new THREE.Color(1.0, 0.85, 0.6), new THREE.Color(0.6, 0.2, 0.15), t
    );
    ambientIntensity = 0.5 - t * 0.3;
    ambientColor = new THREE.Color().lerpColors(
      new THREE.Color(0.25, 0.2, 0.3), new THREE.Color(0.1, 0.05, 0.15), t
    );
    exposure = 1.3 - t * 0.6;
  } else {
    // Night: deep blue, moonlit
    const t = (phase - 0.65) / 0.35;
    const pulse = 0.5 + 0.5 * Math.sin(t * Math.PI); // peaks mid-night
    sunIntensity = 0.15 + pulse * 0.1;
    sunColor = new THREE.Color(0.3, 0.35, 0.6);
    ambientIntensity = 0.15 + pulse * 0.05;
    ambientColor = new THREE.Color(0.05, 0.08, 0.2);
    exposure = 0.6 + pulse * 0.15;
  }

  return { sunIntensity, sunColor, ambientIntensity, ambientColor, exposure };
}

// ================================================================
// AMBIENT UNDERWATER AUDIO (Web Audio API)
// ================================================================

let audioCtx = null, audioStarted = false;

function initAudio() {
  if (audioStarted) return;
  audioStarted = true;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const master = audioCtx.createGain();
  master.gain.value = 0.12;
  master.connect(audioCtx.destination);

  // Deep underwater rumble — filtered noise
  const rumbleSize = audioCtx.sampleRate * 4;
  const rumbleBuffer = audioCtx.createBuffer(1, rumbleSize, audioCtx.sampleRate);
  const rumbleData = rumbleBuffer.getChannelData(0);
  for (let i = 0; i < rumbleSize; i++) rumbleData[i] = (Math.random() * 2 - 1);
  const rumble = audioCtx.createBufferSource();
  rumble.buffer = rumbleBuffer;
  rumble.loop = true;
  const rumbleFilter = audioCtx.createBiquadFilter();
  rumbleFilter.type = 'lowpass';
  rumbleFilter.frequency.value = 120;
  rumbleFilter.Q.value = 0.7;
  const rumbleGain = audioCtx.createGain();
  rumbleGain.gain.value = 0.6;
  rumble.connect(rumbleFilter);
  rumbleFilter.connect(rumbleGain);
  rumbleGain.connect(master);
  rumble.start();

  // Mid-range water ambiance — bandpass filtered noise
  const ambSize = audioCtx.sampleRate * 3;
  const ambBuffer = audioCtx.createBuffer(1, ambSize, audioCtx.sampleRate);
  const ambData = ambBuffer.getChannelData(0);
  for (let i = 0; i < ambSize; i++) ambData[i] = (Math.random() * 2 - 1);
  const amb = audioCtx.createBufferSource();
  amb.buffer = ambBuffer;
  amb.loop = true;
  const ambFilter = audioCtx.createBiquadFilter();
  ambFilter.type = 'bandpass';
  ambFilter.frequency.value = 500;
  ambFilter.Q.value = 0.5;
  const ambGain = audioCtx.createGain();
  ambGain.gain.value = 0.15;
  amb.connect(ambFilter);
  ambFilter.connect(ambGain);
  ambGain.connect(master);
  amb.start();

  // Periodic bubble sounds
  function playBubble() {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    const baseFreq = 600 + Math.random() * 800;
    osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(baseFreq * 2.5, audioCtx.currentTime + 0.08);
    const bGain = audioCtx.createGain();
    bGain.gain.setValueAtTime(0.06 + Math.random() * 0.04, audioCtx.currentTime);
    bGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
    const bFilter = audioCtx.createBiquadFilter();
    bFilter.type = 'bandpass';
    bFilter.frequency.value = 1200;
    bFilter.Q.value = 2;
    osc.connect(bFilter);
    bFilter.connect(bGain);
    bGain.connect(master);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.2);
    // Schedule next bubble
    setTimeout(playBubble, 2000 + Math.random() * 6000);
  }
  setTimeout(playBubble, 1000);

  // Ambient procedural music — gentle pentatonic tones that shift with day/night
  const pentatonic = [261.6, 293.7, 329.6, 392.0, 440.0, 523.3, 587.3, 659.3]; // C pentatonic
  const nightNotes = [220.0, 246.9, 277.2, 329.6, 370.0, 440.0, 493.9, 554.4]; // darker minor
  function playTone() {
    const dayPhase = getDayPhase(performance.now() * 0.001);
    const isNight = dayPhase >= 0.5;
    const notes = isNight ? nightNotes : pentatonic;
    const freq = notes[Math.floor(Math.random() * notes.length)];
    const octaveShift = Math.random() < 0.3 ? 0.5 : (Math.random() < 0.2 ? 2 : 1);
    const noteFreq = freq * octaveShift;
    const duration = 1.5 + Math.random() * 3;
    const now = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(noteFreq, now);

    // Very gentle vibrato
    const vibrato = audioCtx.createOscillator();
    const vibratoGain = audioCtx.createGain();
    vibrato.frequency.value = 3 + Math.random() * 2;
    vibratoGain.gain.value = noteFreq * 0.003;
    vibrato.connect(vibratoGain);
    vibratoGain.connect(osc.frequency);
    vibrato.start(now);
    vibrato.stop(now + duration + 0.5);

    const toneGain = audioCtx.createGain();
    const vol = 0.015 + Math.random() * 0.015;
    toneGain.gain.setValueAtTime(0, now);
    toneGain.gain.linearRampToValueAtTime(vol, now + duration * 0.3);
    toneGain.gain.linearRampToValueAtTime(vol * 0.7, now + duration * 0.7);
    toneGain.gain.linearRampToValueAtTime(0.001, now + duration);

    const toneFilter = audioCtx.createBiquadFilter();
    toneFilter.type = 'lowpass';
    toneFilter.frequency.value = isNight ? 600 : 900;
    toneFilter.Q.value = 1;

    osc.connect(toneFilter);
    toneFilter.connect(toneGain);
    toneGain.connect(master);
    osc.start(now);
    osc.stop(now + duration + 0.1);

    // Schedule next tone with some overlap
    setTimeout(playTone, (duration * 0.6 + Math.random() * 2) * 1000);
  }
  setTimeout(playTone, 3000);
}

// Start audio on first user interaction (browsers require user gesture)
function tryStartAudio() {
  initAudio();
  document.removeEventListener('click', tryStartAudio);
  document.removeEventListener('touchstart', tryStartAudio);
  document.removeEventListener('keydown', tryStartAudio);
}
document.addEventListener('click', tryStartAudio);
document.addEventListener('touchstart', tryStartAudio);
document.addEventListener('keydown', tryStartAudio);

// ================================================================
// RENDER LOOP
// ================================================================

let lastTime = 0;

function animate(now) {
  requestAnimationFrame(animate);
  const time = now * 0.001;
  let dt = Math.min(time - lastTime, 0.05);
  lastTime = time;
  if (dt <= 0) return;

  // Pause support
  if (paused) {
    renderer.render(scene, camera);
    return;
  }
  dt *= simSpeed;

  // Day/night cycle
  const dayPhase = getDayPhase(time);
  const dayLight = getDayLighting(dayPhase);
  sunLight.intensity = dayLight.sunIntensity;
  sunLight.color.copy(dayLight.sunColor);
  scene.children[0].intensity = dayLight.ambientIntensity; // ambient light
  scene.children[0].color.copy(dayLight.ambientColor);
  renderer.toneMappingExposure = dayLight.exposure;
  // Underwater glow responds to day cycle
  underwaterGlow.intensity = 0.2 + dayLight.sunIntensity * 0.3;

  // FPS counter (uses real dt, not sim-scaled)
  updateFPS(Math.min(time - (lastTime - dt / simSpeed), 0.05) || dt);

  // Smooth zoom lerp
  camRadius += (camRadiusTarget - camRadius) * Math.min(1, dt * 6);

  // Fish follow camera
  if (followedFish && (!followedFish.alive || followedFish.dying)) stopFollowing();

  // Auto-rotate when not dragging + subtle cinematic sway
  if (!dragging && !followedFish) {
    camTheta += (underwaterMode ? 0.015 : 0.04) * dt;
    // Subtle camera breathing (very slight vertical bob)
    if (!underwaterMode) {
      const breathe = Math.sin(time * 0.3) * 0.002;
      camPhi += breathe * dt;
    }
  }

  // Update camera
  let lookTarget;
  if (followedFish) {
    lookTarget = followedFish.pos;
    const fCamRadius = Math.min(camRadius, 6);
    camera.position.set(
      followedFish.pos.x + fCamRadius * Math.sin(camPhi) * Math.sin(camTheta),
      followedFish.pos.y + fCamRadius * Math.cos(camPhi),
      followedFish.pos.z + fCamRadius * Math.sin(camPhi) * Math.cos(camTheta)
    );
  } else if (underwaterMode) {
    // Dive mode: camera inside the bowl, looking outward
    const diveY = SAND_Y + 2.0 + Math.sin(time * 0.3) * 0.3; // gentle bob
    const diveR = Math.min(camRadius, 2.5);
    camera.position.set(
      diveR * Math.sin(camTheta) * 0.5,
      diveY,
      diveR * Math.cos(camTheta) * 0.5
    );
    // Look direction based on phi/theta
    lookTarget = new THREE.Vector3(
      camera.position.x + Math.sin(camPhi) * Math.sin(camTheta) * 3,
      camera.position.y + Math.cos(camPhi) * 0.5,
      camera.position.z + Math.sin(camPhi) * Math.cos(camTheta) * 3
    );
    // Reduce FOV underwater for immersion
    camera.fov += (55 - camera.fov) * 0.05;
    camera.updateProjectionMatrix();
  } else {
    lookTarget = new THREE.Vector3(0, -0.5, 0);
    camera.position.set(
      camRadius * Math.sin(camPhi) * Math.sin(camTheta),
      camRadius * Math.cos(camPhi),
      camRadius * Math.sin(camPhi) * Math.cos(camTheta)
    );
    // FOV: cinema mode uses wider FOV
    const targetFov = cinemaMode ? 55 : 45;
    camera.fov += (targetFov - camera.fov) * 0.05;
    camera.updateProjectionMatrix();
  }
  camera.lookAt(lookTarget);

  // Glass sparkle + light pool
  glassMat.uniforms.uTime.value = time;
  poolMat.uniforms.uTime.value = time;

  // Water waves
  waterMat.uniforms.uTime.value = time;

  // Sand caustics
  sandMat.uniforms.uTime.value = time;

  // God rays — dimmed at night
  const godRayIntensity = dayLight.sunIntensity;
  for (const grMat of godRays) {
    grMat.uniforms.uTime.value = time;
    grMat.uniforms.uIntensity.value = godRayIntensity;
  }

  // Background color shift + day phase
  bgMat.uniforms.uTime.value = time;
  bgMat.uniforms.uDayPhase.value = dayPhase;
  atmosMat.uniforms.uDayPhase.value = dayPhase;

  // Particle drift with gentle circular current + bioluminescence at night
  const pp = particleGeo.attributes.position;
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    let px = pp.getX(i), py = pp.getY(i), pz = pp.getZ(i);
    py += particleSpeeds[i] * dt * 60;
    // Gentle circular current (vortex)
    const dist = Math.sqrt(px * px + pz * pz);
    if (dist > 0.1) {
      const currentStrength = 0.008 * dt * 60;
      const nx = -pz / dist, nz = px / dist; // tangent direction
      px += nx * currentStrength;
      pz += nz * currentStrength;
      // Slight inward drift to prevent spreading
      px -= (px / dist) * 0.001 * dt * 60;
      pz -= (pz / dist) * 0.001 * dt * 60;
    }
    if (py > WATER_Y - 0.3) {
      py = SAND_Y + 0.5;
      const a = Math.random() * Math.PI * 2, r = Math.random() * 3;
      px = Math.cos(a) * r;
      pz = Math.sin(a) * r;
    }
    pp.setX(i, px);
    pp.setY(i, py);
    pp.setZ(i, pz);
  }
  pp.needsUpdate = true;
  // Plankton glow brighter at night (bioluminescence)
  const nightFactor = dayPhase >= 0.65 ? 1.0 : dayPhase >= 0.5 ? (dayPhase - 0.5) / 0.15 : 0;
  particles.material.opacity = 0.5 + nightFactor * 0.5;
  particles.material.size = 0.06 + nightFactor * 0.06;
  // Color shift to blue-green at night
  const planktonR = 0.78 - nightFactor * 0.4;
  const planktonG = 0.86 + nightFactor * 0.1;
  const planktonB = 1.0;
  particles.material.color.setRGB(planktonR, planktonG, planktonB);

  // Bubble rise
  const bp = bubbleGeo.attributes.position;
  for (let i = 0; i < BUBBLE_COUNT; i++) {
    let by = bp.getY(i) + bubbleSpeeds2[i] * dt;
    // Wobble horizontally
    const wobble = Math.sin(time * 2 + bubblePhases[i]) * 0.005;
    bp.setX(i, bp.getX(i) + wobble);
    bp.setZ(i, bp.getZ(i) + Math.cos(time * 1.5 + bubblePhases[i] * 1.3) * 0.003);
    bubbleLifes[i] -= dt;
    if (by > WATER_Y - 0.2 || bubbleLifes[i] <= 0) {
      // Small ripple when bubble pops at surface
      if (by > WATER_Y - 0.25 && Math.random() < 0.15) {
        createSplashRipple(bp.getX(i), bp.getZ(i));
      }
      resetBubble(i);
    }
    else bp.setY(i, by);
  }
  bp.needsUpdate = true;

  // Air stone bubble stream
  const abp = airBubbleGeo.attributes.position;
  for (let i = 0; i < AIR_BUBBLE_COUNT; i++) {
    let aby = abp.getY(i) + airBubbleSpeeds[i] * dt;
    abp.setX(i, abp.getX(i) + Math.sin(time * 3 + airBubblePhases2[i]) * 0.003);
    abp.setZ(i, abp.getZ(i) + Math.cos(time * 2.5 + airBubblePhases2[i]) * 0.002);
    if (aby > WATER_Y - 0.15) resetAirBubble(i);
    else abp.setY(i, aby);
  }
  abp.needsUpdate = true;

  // Seaweed sway (shader-driven)
  seaweeds.forEach(sw => { sw.mat.uniforms.uTime.value = time; });

  // Anemone tentacles
  anemones.forEach(a => { a.mat.uniforms.uTime.value = time; });

  // Anemone fireflies — glow and orbit at night
  const ffp = fireflyGeo.attributes.position;
  fireflies.material.opacity = nightFactor * 0.8;
  for (let i = 0; i < FIREFLY_COUNT; i++) {
    const fd = fireflyData[i];
    const angle = fd.phase + time * fd.orbitSpeed;
    ffp.setX(i, fd.centerX + Math.cos(angle) * fd.orbitR);
    ffp.setZ(i, fd.centerZ + Math.sin(angle) * fd.orbitR);
    ffp.setY(i, fd.baseY + Math.sin(time * fd.bobSpeed + fd.bobPhase) * 0.15);
  }
  ffp.needsUpdate = true;

  // Coral polyp animation — gentle pulsing and swaying
  for (let i = 0; i < coralPolyps.length; i++) {
    const cp = coralPolyps[i];
    if (cp.isBulb) {
      // Pulsing glow on central bulb
      const pulse = 1.0 + Math.sin(time * 1.5 + cp.seed) * 0.15;
      cp.mesh.scale.setScalar(pulse);
    } else {
      // Sway tentacle polyps
      const sway = Math.sin(time * 2.0 + cp.seed) * 0.12;
      const sway2 = Math.cos(time * 1.5 + cp.seed * 0.7) * 0.08;
      cp.mesh.rotation.x = sway * Math.cos(cp.baseAngle);
      cp.mesh.rotation.z = sway * Math.sin(cp.baseAngle) + sway2;
      cp.mesh.position.y = cp.baseY + Math.sin(time * 1.8 + cp.seed) * 0.008;
    }
  }

  // Compute school pulse for tetras — synchronized shimmer when close together
  let schoolPulse = 0;
  const tetras = fishList.filter(f => f.alive && f.speciesKey === 'small');
  if (tetras.length >= 3) {
    let closeCount = 0;
    for (let i = 0; i < tetras.length; i++) {
      for (let j = i + 1; j < tetras.length; j++) {
        if (tetras[i].pos.distanceTo(tetras[j].pos) < 1.5) closeCount++;
      }
    }
    const maxPairs = tetras.length * (tetras.length - 1) / 2;
    schoolPulse = Math.min(1.0, closeCount / Math.max(1, maxPairs * 0.5));
  }

  // Fish boids + update
  const eyeGlowAmount = nightFactor * 0.3;
  for (let i = 0; i < fishList.length; i++) {
    if (!fishList[i].alive) continue;
    boids(fishList[i], fishList, dt);
    fishList[i].update(dt, time);
    // School pulse for tetras
    if (fishList[i].speciesKey === 'small') {
      fishList[i].mat.uniforms.uSchoolPulse.value += (schoolPulse - fishList[i].mat.uniforms.uSchoolPulse.value) * Math.min(1, dt * 3);
    }
    // Eye glow at night
    if (fishList[i].eyeMat) {
      fishList[i].eyeMat.emissiveIntensity = eyeGlowAmount;
      if (eyeGlowAmount > 0) {
        const glowColor = fishList[i].speciesKey === 'large' ? 0x6622aa :
                          fishList[i].speciesKey === 'medium' ? 0xaa8822 : 0x2288aa;
        fishList[i].eyeMat.emissive.setHex(glowColor);
      }
    }
    // Sand disturbance — kick up sand puffs when swimming near bottom
    if (fishList[i].pos.y < SAND_PUFF_THRESHOLD && fishList[i].vel.length() > 0.3 && Math.random() < 0.03) {
      createSandPuff(fishList[i].pos.x, fishList[i].pos.z);
    }
    // Swim trails behind fast fish
    const fishSpd = fishList[i].vel.length();
    if (fishSpd > 0.5 && Math.random() < 0.15) {
      emitTrail(fishList[i].pos);
    }
  }

  // Sand puff particles
  updateSandPuffs(dt);

  // Fish swim trails
  updateTrails(dt);

  // Ecosystem tick
  updateEcosystem(dt);

  // Feeding frenzy decay
  if (feedingFrenzy > 0) feedingFrenzy = Math.max(0, feedingFrenzy - dt);

  // Food particles
  updateFood(dt);

  // Splash ripples
  updateSplashRipples(dt);

  // Mouse scatter update
  if (!dragging) updateMouseScatter();

  // Auto-feed
  autoFeedTimer += dt;
  if (autoFeedTimer >= AUTO_FEED_INTERVAL) {
    autoFeedTimer = 0;
    const angle = Math.random() * Math.PI * 2;
    const r = 0.5 + Math.random() * 1.5;
    dropFood(new THREE.Vector3(Math.cos(angle) * r, WATER_Y, Math.sin(angle) * r));
  }

  // HUD
  updateHUD(dt, time);
  updateDay(dt);

  renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// Fade out loading screen + welcome
const loadingEl = document.getElementById('loading');
setTimeout(() => {
  loadingEl.style.opacity = '0';
  setTimeout(() => loadingEl.remove(), 1000);
}, 500);
setTimeout(() => showEvent('Welcome to The Impossible Fishbowl'), 2000);
setTimeout(() => showEvent('Press H for controls'), 4000);

// ================================================================
// RESIZE
// ================================================================

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

</script>
</body>
</html>
