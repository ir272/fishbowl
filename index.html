<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Impossible Fishbowl</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#000;font-family:'Helvetica Neue',Arial,sans-serif}
canvas{display:block}
#hud{
  position:fixed;bottom:24px;left:24px;
  pointer-events:none;user-select:none;z-index:10;
}
#hud *{pointer-events:auto}
.hud-panel{
  background:rgba(5,10,25,0.55);
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  border:1px solid rgba(100,140,200,0.15);
  border-radius:12px;padding:14px 18px;
  color:rgba(180,200,230,0.9);font-size:13px;
  letter-spacing:0.3px;min-width:160px;
}
.hud-title{
  font-size:10px;text-transform:uppercase;letter-spacing:1.5px;
  color:rgba(140,170,220,0.6);margin-bottom:10px;
}
.species-row{
  display:flex;align-items:center;gap:8px;
  margin:6px 0;font-variant-numeric:tabular-nums;
}
.species-dot{
  width:8px;height:8px;border-radius:50%;flex-shrink:0;
  box-shadow:0 0 6px currentColor;
}
.species-name{flex:1;font-size:12px}
.species-count{font-size:14px;font-weight:500;min-width:20px;text-align:right}
.hud-day{
  margin-top:10px;padding-top:8px;
  border-top:1px solid rgba(100,140,200,0.1);
  font-size:11px;color:rgba(140,170,220,0.5);
}
#feed-btn{
  display:block;margin-top:10px;
  background:rgba(100,140,200,0.15);border:1px solid rgba(100,140,200,0.25);
  color:rgba(180,200,230,0.8);border-radius:8px;
  padding:8px 16px;font-size:12px;cursor:pointer;
  transition:all 0.2s;letter-spacing:0.5px;width:100%;
}
#feed-btn:hover{background:rgba(100,140,200,0.25);color:#fff}
#feed-btn:active{transform:scale(0.97)}
.hint{
  position:fixed;bottom:24px;right:24px;
  color:rgba(140,170,220,0.3);font-size:11px;
  pointer-events:none;z-index:10;text-align:right;
  line-height:1.6;
}
.vignette{
  position:fixed;top:0;left:0;right:0;bottom:0;
  pointer-events:none;z-index:1;
  background:radial-gradient(ellipse at center,transparent 55%,rgba(0,2,8,0.5) 100%);
}
</style>
</head>
<body>
<div id="hud">
  <div class="hud-panel">
    <div class="hud-title">Population</div>
    <div class="species-row">
      <div class="species-dot" style="color:#22aaff"></div>
      <span class="species-name">Neon Tetra</span>
      <span class="species-count" id="count-small">0</span>
    </div>
    <div class="species-row">
      <div class="species-dot" style="color:#ffbb44"></div>
      <span class="species-name">Angelfish</span>
      <span class="species-count" id="count-medium">0</span>
    </div>
    <div class="species-row">
      <div class="species-dot" style="color:#bb44ee"></div>
      <span class="species-name">Betta</span>
      <span class="species-count" id="count-large">0</span>
    </div>
    <div class="hud-day" id="day-counter">Day 1</div>
    <div class="hud-day" id="time-of-day" style="border:none;margin-top:4px;padding-top:0"></div>
    <button id="feed-btn">Drop Food</button>
  </div>
</div>
<div class="vignette"></div>
<div class="hint">
  Click to feed<br>
  Drag to orbit<br>
  Scroll to zoom
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
'use strict';

// ================================================================
// THE IMPOSSIBLE FISHBOWL
// A mesmerizing real-time 3D aquarium ecosystem
// ================================================================

// --- Seeded RNG for deterministic environment ---
function mkRng(seed) {
  let s = seed;
  return function() { s = (s * 9301 + 49297) % 233280; return s / 233280; };
}
const rng = mkRng(42);

// ================================================================
// RENDERER & SCENE
// ================================================================

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x030912);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);

// ================================================================
// LIGHTING
// ================================================================

scene.add(new THREE.AmbientLight(0x334466, 0.5));

const sunLight = new THREE.DirectionalLight(0xffeedd, 0.9);
sunLight.position.set(3, 10, 5);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(1024, 1024);
Object.assign(sunLight.shadow.camera, { near: 1, far: 25, left: -7, right: 7, top: 7, bottom: -7 });
scene.add(sunLight);

const fillLight = new THREE.PointLight(0x446688, 0.3, 15);
fillLight.position.set(-3, -2, 4);
scene.add(fillLight);

const underwaterGlow = new THREE.PointLight(0x2277aa, 0.4, 10);
underwaterGlow.position.set(0, -2, 0);
scene.add(underwaterGlow);

// ================================================================
// CONSTANTS
// ================================================================

const BOWL_RADIUS = 5;
const BOWL_THETA_START = Math.acos(0.6);        // ~0.927 rad
const BOWL_OPENING_Y = BOWL_RADIUS * 0.6;       // 3.0
const BOWL_OPENING_R = BOWL_RADIUS * Math.sin(BOWL_THETA_START); // 4.0
const WATER_Y = 2.5;
const SAND_Y = -4.0;
const SAND_RADIUS = Math.sqrt(BOWL_RADIUS * BOWL_RADIUS - SAND_Y * SAND_Y) - 0.25; // ~2.75

// ================================================================
// GLASS BOWL
// ================================================================

const bowlGeo = new THREE.SphereGeometry(
  BOWL_RADIUS, 64, 48,
  0, Math.PI * 2,
  BOWL_THETA_START, Math.PI - BOWL_THETA_START
);

const glassMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  side: THREE.DoubleSide,
  vertexShader: `
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    void main() {
      vNormal = normalize(mat3(modelMatrix) * normal);
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    void main() {
      vec3 viewDir = normalize(cameraPosition - vWorldPos);
      vec3 n = gl_FrontFacing ? vNormal : -vNormal;
      float fresnel = pow(1.0 - abs(dot(n, viewDir)), 3.5);

      // Chromatic edge tint
      vec3 baseColor = vec3(0.7, 0.85, 0.95);
      vec3 edgeColor = vec3(0.8, 0.9, 1.0);
      vec3 rainbowEdge = vec3(0.85 + fresnel * 0.1, 0.9, 1.0 - fresnel * 0.05);
      vec3 color = mix(baseColor, rainbowEdge, fresnel);

      // Multiple specular highlights (main + rim)
      vec3 lightDir = normalize(vec3(3.0, 10.0, 5.0));
      vec3 h = normalize(lightDir + viewDir);
      float spec = pow(max(dot(n, h), 0.0), 196.0) * 0.7;
      vec3 lightDir2 = normalize(vec3(-2.0, 6.0, -3.0));
      vec3 h2 = normalize(lightDir2 + viewDir);
      float spec2 = pow(max(dot(n, h2), 0.0), 96.0) * 0.3;
      color += (spec + spec2) * vec3(1.0, 0.98, 0.95);

      // Glass rim glow
      float rimGlow = pow(fresnel, 5.0) * 0.15;
      color += rimGlow * vec3(0.6, 0.8, 1.0);

      float alpha = mix(0.03, 0.28, fresnel) + (spec + spec2) * 0.4 + rimGlow;
      gl_FragColor = vec4(color, alpha);
    }
  `
});

const bowlMesh = new THREE.Mesh(bowlGeo, glassMat);
scene.add(bowlMesh);

// Bowl rim
const rimGeo = new THREE.TorusGeometry(BOWL_OPENING_R, 0.1, 12, 64);
const rimMat = new THREE.MeshStandardMaterial({
  color: 0xbbccdd, roughness: 0.05, metalness: 0.2,
  transparent: true, opacity: 0.5
});
const rim = new THREE.Mesh(rimGeo, rimMat);
rim.rotation.x = Math.PI / 2;
rim.position.y = BOWL_OPENING_Y;
scene.add(rim);

// ================================================================
// WATER SURFACE
// ================================================================

const waterGeo = new THREE.CircleGeometry(
  Math.sqrt(BOWL_RADIUS * BOWL_RADIUS - WATER_Y * WATER_Y) - 0.15, 64
);
waterGeo.rotateX(-Math.PI / 2);

const waterMat = new THREE.ShaderMaterial({
  transparent: true, depthWrite: false, side: THREE.DoubleSide,
  uniforms: { uTime: { value: 0 } },
  vertexShader: `
    uniform float uTime;
    varying vec2 vUv;
    varying vec3 vWorldPos;
    void main() {
      vUv = uv;
      vec3 pos = position;
      float t = uTime;
      pos.y += sin(pos.x * 2.0 + t * 0.8) * 0.04
             + cos(pos.z * 2.5 + t * 0.6) * 0.03
             + sin(pos.x * 4.0 - pos.z * 3.0 + t * 1.2) * 0.015;
      vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    varying vec2 vUv;
    varying vec3 vWorldPos;
    void main() {
      float d = length(vUv - 0.5) * 2.0;
      // Ripple pattern on surface
      float ripple = sin(vWorldPos.x * 5.0 + uTime * 0.7)
                   * cos(vWorldPos.z * 4.0 + uTime * 0.5) * 0.3 + 0.7;
      float alpha = 0.1 * (1.0 - d * 0.4) * ripple;
      // Subtle color variation
      vec3 waterColor = mix(vec3(0.2, 0.45, 0.65), vec3(0.35, 0.6, 0.75), ripple);
      // Bright edge where water meets glass
      float edge = smoothstep(0.85, 1.0, d);
      waterColor += edge * vec3(0.2, 0.3, 0.4);
      alpha += edge * 0.08;
      gl_FragColor = vec4(waterColor, alpha);
    }
  `
});
const waterSurface = new THREE.Mesh(waterGeo, waterMat);
waterSurface.position.y = WATER_Y;
scene.add(waterSurface);

// ================================================================
// SAND FLOOR
// ================================================================

const sandCanvas = document.createElement('canvas');
sandCanvas.width = sandCanvas.height = 512;
const sCtx = sandCanvas.getContext('2d');
sCtx.fillStyle = '#c4a882';
sCtx.fillRect(0, 0, 512, 512);
for (let i = 0; i < 40000; i++) {
  const b = rng() * 30 - 15 | 0;
  sCtx.fillStyle = `rgb(${196 + b},${168 + b},${130 + b})`;
  sCtx.fillRect(rng() * 512, rng() * 512, 1 + rng() * 2, 1 + rng() * 2);
}
const sandTexture = new THREE.CanvasTexture(sandCanvas);
sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping;

const sandGeo = new THREE.CircleGeometry(SAND_RADIUS, 64);
sandGeo.rotateX(-Math.PI / 2);
const sp = sandGeo.attributes.position;
for (let i = 0; i < sp.count; i++) {
  const x = sp.getX(i), z = sp.getZ(i);
  const d = Math.sqrt(x * x + z * z) / SAND_RADIUS;
  sp.setY(i, sp.getY(i) + rng() * 0.12 * (1 - d));
}
sandGeo.computeVertexNormals();

const sandMat = new THREE.ShaderMaterial({
  uniforms: {
    uSandTex: { value: sandTexture },
    uTime: { value: 0 }
  },
  vertexShader: `
    varying vec2 vUv;
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      vUv = uv;
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      vNormal = normalize(mat3(modelMatrix) * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D uSandTex;
    uniform float uTime;
    varying vec2 vUv;
    varying vec3 vWorldPos;
    varying vec3 vNormal;

    float caustic(vec2 p, float t) {
      float c = 0.0;
      for (int i = 1; i <= 4; i++) {
        float fi = float(i);
        vec2 q = p * fi * 1.8 + t * vec2(0.25 * fi, 0.18 * fi);
        c += abs(sin(q.x + sin(q.y * 1.3 + t * 0.4))
               * sin(q.y + sin(q.x * 0.7 + t * 0.3)));
      }
      return pow(c * 0.25, 2.0);
    }

    void main() {
      vec3 sand = texture2D(uSandTex, vUv).rgb;
      float caust = caustic(vWorldPos.xz * 0.6, uTime * 0.35);
      vec3 causticColor = vec3(0.35, 0.55, 0.85) * caust * 2.0;
      vec3 lightDir = normalize(vec3(3.0, 10.0, 5.0));
      float diff = max(dot(vNormal, lightDir), 0.0) * 0.5 + 0.5;
      vec3 color = sand * diff + causticColor;
      gl_FragColor = vec4(color, 1.0);
    }
  `
});
const sand = new THREE.Mesh(sandGeo, sandMat);
sand.position.y = SAND_Y;
sand.receiveShadow = true;
scene.add(sand);

// ================================================================
// ROCKS
// ================================================================

function createRock(size, x, z) {
  const geo = new THREE.IcosahedronGeometry(size, 1);
  const p = geo.attributes.position;
  for (let i = 0; i < p.count; i++) {
    const n = 0.7 + rng() * 0.6;
    p.setXYZ(i, p.getX(i) * n, p.getY(i) * (0.5 + rng() * 0.3), p.getZ(i) * n);
  }
  geo.computeVertexNormals();
  const shade = 0.2 + rng() * 0.15;
  const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
    color: new THREE.Color(shade, shade * 0.9, shade * 0.8), roughness: 0.9
  }));
  mesh.position.set(x, SAND_Y + size * 0.3, z);
  mesh.rotation.set(rng() * Math.PI, rng() * Math.PI, rng() * Math.PI);
  mesh.castShadow = mesh.receiveShadow = true;
  scene.add(mesh);
  return mesh;
}

createRock(0.5, -1.5, 1.0);
createRock(0.35, 1.2, 1.5);
createRock(0.45, -0.6, -1.5);
createRock(0.55, 2.0, -0.5);
createRock(0.35, -2.0, -0.3);
createRock(0.3, 0.3, -2.0);

// ================================================================
// CORAL
// ================================================================

function createCoral(x, z, color, height, branchCount) {
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.55 });

  // Trunk
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry(0.04, 0.12, height, 8), mat
  );
  trunk.position.y = height / 2;
  group.add(trunk);

  // Branches
  for (let i = 0; i < branchCount; i++) {
    const bh = height * (0.3 + rng() * 0.4);
    const branch = new THREE.Mesh(
      new THREE.CylinderGeometry(0.02, 0.06, bh, 6), mat
    );
    const startY = height * (0.3 + rng() * 0.5);
    const angle = rng() * Math.PI * 2;
    const tilt = 0.3 + rng() * 0.5;
    branch.position.set(Math.sin(angle) * 0.15, startY + bh * 0.4, Math.cos(angle) * 0.15);
    branch.rotation.set(tilt * Math.cos(angle), 0, tilt * Math.sin(angle));
    group.add(branch);

    // Tip bulb
    const bulb = new THREE.Mesh(
      new THREE.SphereGeometry(0.04 + rng() * 0.04, 8, 8), mat
    );
    bulb.position.set(
      branch.position.x + Math.sin(angle) * bh * 0.3,
      startY + bh * 0.8,
      branch.position.z + Math.cos(angle) * bh * 0.3
    );
    group.add(bulb);
  }

  group.position.set(x, SAND_Y + 0.05, z);
  scene.add(group);
  return group;
}

createCoral(1.5, -1.0, 0xff5566, 1.5, 5);
createCoral(-1.2, -1.8, 0xff8844, 1.2, 4);
createCoral(-0.3, 2.0, 0xaa44cc, 1.0, 3);
createCoral(0.8, 1.8, 0xff6699, 0.8, 3);

// Seaweed with vertex shader sway
function createSeaweed(x, z, height, color) {
  const geo = new THREE.PlaneGeometry(0.3, height, 2, 12);
  // Add initial curve
  const p = geo.attributes.position;
  for (let i = 0; i < p.count; i++) {
    const y = p.getY(i);
    const t = (y / height + 0.5); // 0 at base, 1 at tip
    p.setX(i, p.getX(i) + Math.sin(t * 2.5) * 0.12 * t);
    // Taper width toward tip
    if (t > 0.6) p.setX(i, p.getX(i) * (1 - (t - 0.6) * 0.7));
  }
  geo.computeVertexNormals();

  const seedVal = rng() * 10;
  const mat = new THREE.ShaderMaterial({
    side: THREE.DoubleSide, transparent: true,
    uniforms: {
      uTime: { value: 0 },
      uColor: { value: new THREE.Color(color) },
      uSeed: { value: seedVal }
    },
    vertexShader: `
      uniform float uTime;
      uniform float uSeed;
      varying vec2 vUv;
      varying float vHeight;
      void main() {
        vUv = uv;
        vHeight = uv.y;
        vec3 pos = position;
        float t = uv.y; // 0=base, 1=tip
        float sway = sin(uTime * 0.8 + uSeed + t * 3.0) * t * t * 0.3;
        sway += sin(uTime * 1.3 + uSeed * 2.0 + t * 2.0) * t * t * 0.15;
        pos.x += sway;
        pos.z += cos(uTime * 0.6 + uSeed * 1.5 + t * 2.5) * t * t * 0.1;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 uColor;
      varying vec2 vUv;
      varying float vHeight;
      void main() {
        vec3 c = uColor * (0.7 + 0.3 * vHeight);
        // Lighter edges
        float edge = abs(vUv.x - 0.5) * 2.0;
        c += vec3(0.05, 0.1, 0.03) * (1.0 - edge);
        float alpha = 0.85 * (1.0 - smoothstep(0.85, 1.0, vHeight));
        gl_FragColor = vec4(c, alpha);
      }
    `
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, SAND_Y + height * 0.5, z);
  mesh.rotation.y = rng() * Math.PI;
  scene.add(mesh);
  return { mesh, mat };
}

const seaweeds = [];
seaweeds.push(createSeaweed(-1.8, 0.5, 2.2, 0x2d6b3a));
seaweeds.push(createSeaweed(1.6, 0.8, 1.7, 0x3a7d4a));
seaweeds.push(createSeaweed(-0.8, 2.0, 2.0, 0x1f5c2e));
seaweeds.push(createSeaweed(0.5, -2.2, 1.5, 0x2a6e38));
seaweeds.push(createSeaweed(-2.2, -0.8, 1.3, 0x287a3d));
seaweeds.push(createSeaweed(0.0, 2.3, 1.1, 0x348c48));
seaweeds.push(createSeaweed(2.1, -1.2, 1.8, 0x2b7040));

// ================================================================
// FLOATING PARTICLES (plankton / debris)
// ================================================================

const pCanvas = document.createElement('canvas');
pCanvas.width = pCanvas.height = 32;
const pCtx = pCanvas.getContext('2d');
const pGrad = pCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
pGrad.addColorStop(0, 'rgba(200,220,255,0.9)');
pGrad.addColorStop(1, 'rgba(200,220,255,0)');
pCtx.fillStyle = pGrad;
pCtx.fillRect(0, 0, 32, 32);
const pTex = new THREE.CanvasTexture(pCanvas);

const PARTICLE_COUNT = 250;
const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
const particleSpeeds = new Float32Array(PARTICLE_COUNT);
for (let i = 0; i < PARTICLE_COUNT; i++) {
  const angle = rng() * Math.PI * 2;
  const r = rng() * 3.0;
  const y = SAND_Y + 0.5 + rng() * (WATER_Y - SAND_Y - 1);
  particlePositions[i * 3] = Math.cos(angle) * r;
  particlePositions[i * 3 + 1] = y;
  particlePositions[i * 3 + 2] = Math.sin(angle) * r;
  particleSpeeds[i] = 0.005 + rng() * 0.01;
}
const particleGeo = new THREE.BufferGeometry();
particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

const particles = new THREE.Points(particleGeo, new THREE.PointsMaterial({
  map: pTex, size: 0.06, transparent: true, opacity: 0.5,
  blending: THREE.AdditiveBlending, depthWrite: false
}));
scene.add(particles);

// ================================================================
// RISING BUBBLES
// ================================================================

const BUBBLE_COUNT = 35;
const bubblePositions = new Float32Array(BUBBLE_COUNT * 3);
const bubbleSpeeds2 = new Float32Array(BUBBLE_COUNT);
const bubblePhases = new Float32Array(BUBBLE_COUNT);
const bubbleLifes = new Float32Array(BUBBLE_COUNT);

function resetBubble(i) {
  const angle = Math.random() * Math.PI * 2;
  const r = 0.3 + Math.random() * 2.2;
  bubblePositions[i * 3] = Math.cos(angle) * r;
  bubblePositions[i * 3 + 1] = SAND_Y + 0.2 + Math.random() * 0.5;
  bubblePositions[i * 3 + 2] = Math.sin(angle) * r;
  bubbleSpeeds2[i] = 0.4 + Math.random() * 0.6;
  bubblePhases[i] = Math.random() * Math.PI * 2;
  bubbleLifes[i] = 5 + Math.random() * 10;
}
for (let i = 0; i < BUBBLE_COUNT; i++) resetBubble(i);

const bubbleGeo = new THREE.BufferGeometry();
bubbleGeo.setAttribute('position', new THREE.BufferAttribute(bubblePositions, 3));

// Bubble texture — hollow ring with highlight
const bCanvas = document.createElement('canvas');
bCanvas.width = bCanvas.height = 64;
const bCtx = bCanvas.getContext('2d');
const bGrad = bCtx.createRadialGradient(32, 32, 18, 32, 32, 30);
bGrad.addColorStop(0, 'rgba(180,220,255,0)');
bGrad.addColorStop(0.6, 'rgba(180,220,255,0)');
bGrad.addColorStop(0.82, 'rgba(200,235,255,0.5)');
bGrad.addColorStop(0.92, 'rgba(220,240,255,0.25)');
bGrad.addColorStop(1, 'rgba(200,230,255,0)');
bCtx.fillStyle = bGrad;
bCtx.fillRect(0, 0, 64, 64);
// Highlight dot (specular)
const hGrad = bCtx.createRadialGradient(22, 20, 0, 22, 20, 7);
hGrad.addColorStop(0, 'rgba(255,255,255,0.9)');
hGrad.addColorStop(1, 'rgba(255,255,255,0)');
bCtx.fillStyle = hGrad;
bCtx.fillRect(0, 0, 64, 64);
const bTex = new THREE.CanvasTexture(bCanvas);

const bubbles = new THREE.Points(bubbleGeo, new THREE.PointsMaterial({
  map: bTex, size: 0.18, transparent: true, opacity: 0.75,
  depthWrite: false, sizeAttenuation: true
}));
scene.add(bubbles);

// ================================================================
// GOD RAYS (volumetric light shafts)
// ================================================================

const godRays = [];

function createGodRay(x, z, width, angle) {
  const height = WATER_Y - SAND_Y - 0.5;
  const geo = new THREE.PlaneGeometry(width, height, 1, 12);
  // Taper: wider at top, narrower at bottom
  const gp = geo.attributes.position;
  for (let i = 0; i < gp.count; i++) {
    const y = gp.getY(i);
    const t = (y + height / 2) / height; // 0=bottom, 1=top
    gp.setX(i, gp.getX(i) * (0.2 + t * 0.8));
  }
  geo.computeVertexNormals();

  const mat = new THREE.ShaderMaterial({
    transparent: true, depthWrite: false, side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending,
    uniforms: { uTime: { value: 0 }, uOffset: { value: Math.random() * 10 } },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float uTime;
      uniform float uOffset;
      varying vec2 vUv;
      void main() {
        float y = vUv.y;
        float x = abs(vUv.x - 0.5) * 2.0;
        float beam = y * (1.0 - x * x) * 0.07;
        beam *= 0.5 + 0.5 * sin(uTime * 0.2 + uOffset + y * 2.0);
        beam *= 0.7 + 0.3 * sin(uTime * 0.15 + uOffset * 2.0);
        gl_FragColor = vec4(0.45, 0.65, 0.9, beam);
      }
    `
  });

  // Create crossed planes for volume effect
  const group = new THREE.Group();
  const plane1 = new THREE.Mesh(geo, mat);
  group.add(plane1);
  const plane2 = new THREE.Mesh(geo.clone(), mat);
  plane2.rotation.y = Math.PI / 2;
  group.add(plane2);

  group.position.set(x, (WATER_Y + SAND_Y) / 2 + 0.3, z);
  group.rotation.y = angle;
  group.rotation.z = 0.05; // slight tilt
  scene.add(group);
  godRays.push(mat);
  return group;
}

createGodRay(0.8, -0.5, 1.2, 0);
createGodRay(-1.5, 1.0, 0.9, 0.5);
createGodRay(1.2, 1.5, 0.7, -0.3);
createGodRay(-0.5, -1.8, 1.0, 0.8);

// ================================================================
// UNDERWATER ATMOSPHERE (subtle fog volume)
// ================================================================

const atmosGeo = new THREE.SphereGeometry(BOWL_RADIUS - 0.5, 32, 32);
const atmosMat = new THREE.ShaderMaterial({
  transparent: true, depthWrite: false, side: THREE.BackSide,
  uniforms: {},
  vertexShader: `
    varying vec3 vWorldPos;
    void main() {
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vWorldPos;
    void main() {
      float depth = 1.0 - (vWorldPos.y + 5.0) / 8.0;
      depth = clamp(depth, 0.0, 1.0);
      float alpha = depth * 0.08;
      gl_FragColor = vec4(0.05, 0.1, 0.2, alpha);
    }
  `
});
scene.add(new THREE.Mesh(atmosGeo, atmosMat));

// ================================================================
// BACKGROUND
// ================================================================

const bgMat = new THREE.ShaderMaterial({
  side: THREE.BackSide, depthWrite: false,
  uniforms: { uTime: { value: 0 }, uDayPhase: { value: 0 } },
  vertexShader: `
    varying vec3 vPos;
    void main() {
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    varying vec3 vPos;

    float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453); }

    float bokeh(vec3 dir, float seed) {
      vec2 uv = dir.xz / (dir.y + 1.0) * 8.0 + seed;
      vec2 id = floor(uv);
      float rnd = hash(id + seed);
      if (rnd < 0.92) return 0.0;
      vec2 center = vec2(hash(id * 1.3 + seed), hash(id * 2.7 + seed * 0.5));
      float d = length(fract(uv) - center);
      float brightness = (rnd - 0.92) * 12.5;
      float twinkle = 0.7 + 0.3 * sin(uTime * (0.5 + rnd * 2.0) + rnd * 6.28);
      return smoothstep(0.12, 0.0, d) * brightness * twinkle;
    }

    uniform float uDayPhase;

    void main() {
      vec3 dir = normalize(vPos);
      float y = dir.y;

      // Day colors
      vec3 dayTop = vec3(0.08, 0.12, 0.22);
      vec3 dayMid = vec3(0.04, 0.07, 0.15);
      vec3 dayBot = vec3(0.02, 0.03, 0.06);

      // Night colors
      vec3 nightTop = vec3(0.01, 0.015, 0.05);
      vec3 nightMid = vec3(0.005, 0.01, 0.03);
      vec3 nightBot = vec3(0.002, 0.005, 0.015);

      // Dusk/dawn accent
      vec3 dawnAccent = vec3(0.15, 0.06, 0.02);

      float nightMix = 0.0;
      float dawnMix = 0.0;
      if (uDayPhase < 0.15) {
        dawnMix = 1.0 - uDayPhase / 0.15;
        nightMix = dawnMix * 0.5;
      } else if (uDayPhase > 0.5 && uDayPhase < 0.65) {
        dawnMix = (uDayPhase - 0.5) / 0.15;
        nightMix = dawnMix * 0.5;
      } else if (uDayPhase >= 0.65) {
        nightMix = 1.0;
      }

      vec3 top = mix(dayTop, nightTop, nightMix);
      vec3 mid = mix(dayMid, nightMid, nightMix);
      vec3 bot = mix(dayBot, nightBot, nightMix);

      vec3 c = mix(bot, mid, smoothstep(-0.5, 0.0, y));
      c = mix(c, top, smoothstep(0.0, 0.5, y));

      // Dawn/dusk warm glow on horizon
      float horizonGlow = exp(-abs(y) * 4.0) * dawnMix * 0.3;
      c += dawnAccent * horizonGlow;

      // Bokeh dots (brighter at night)
      float bokehStrength = 0.5 + nightMix * 1.5;
      float b = bokeh(dir, 0.0) + bokeh(dir, 3.7) * 0.6;
      c += b * vec3(0.15, 0.2, 0.35) * smoothstep(-0.2, 0.3, y) * bokehStrength;

      gl_FragColor = vec4(c, 1.0);
    }
  `
});
const bgSphere = new THREE.Mesh(new THREE.SphereGeometry(45, 16, 16), bgMat);
bgSphere.renderOrder = -100;
scene.add(bgSphere);

// ================================================================
// BOIDS / FISH SYSTEM
// ================================================================

const BOWL_INNER = BOWL_RADIUS - 0.6; // swim boundary
const fishList = [];

// --- Fish body geometry builder (high detail) ---
function buildFishBody(key, size) {
  const SEGS = 16, RING = 10;
  const len = size * 2.6;
  const hs = key === 'medium' ? 1.5 : key === 'large' ? 1.1 : 1.0;
  const pos = [], idx = [];

  for (let s = 0; s <= SEGS; s++) {
    const t = s / SEGS; // 0=tail, 1=head
    const z = (0.5 - t) * len;

    // Species-specific body profile
    let r;
    if (key === 'small') {
      // Tetra: sleek torpedo
      r = Math.sin(t * Math.PI) * 0.33;
      if (t < 0.1) r *= t / 0.1;
      if (t > 0.85) r *= (1 - t) / 0.15;
    } else if (key === 'medium') {
      // Angelfish: diamond shaped, wider in middle
      r = Math.sin(t * Math.PI) * 0.26;
      if (t < 0.08) r *= t / 0.08;
      // Narrower at front
      if (t > 0.7) r *= Math.pow((1 - t) / 0.3, 0.7);
    } else {
      // Betta: robust body, wider head area
      const peak = 0.55; // peak width behind center
      if (t < peak) r = Math.sin((t / peak) * Math.PI * 0.5) * 0.44;
      else r = Math.cos(((t - peak) / (1 - peak)) * Math.PI * 0.5) * 0.44;
      if (t < 0.08) r *= t / 0.08;
    }
    r *= size;

    for (let j = 0; j <= RING; j++) {
      const a = (j / RING) * Math.PI * 2;
      // Flatten belly slightly
      const yScale = Math.sin(a) > 0 ? hs : hs * 0.85;
      pos.push(Math.cos(a) * r, Math.sin(a) * r * yScale, z);
    }
  }

  for (let s = 0; s < SEGS; s++) {
    for (let j = 0; j < RING; j++) {
      const a = s * (RING + 1) + j;
      idx.push(a, a + RING + 1, a + 1, a + 1, a + RING + 1, a + RING + 2);
    }
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
  geo.setIndex(idx);
  geo.computeVertexNormals();
  return { geo, rest: new Float32Array(pos), len, SEGS, RING };
}

// Reusable objects for smooth rotation
const _lookTarget = new THREE.Vector3();
const _lookMat = new THREE.Matrix4();
const _targetQuat = new THREE.Quaternion();
const _up = new THREE.Vector3(0, 1, 0);

class Fish {
  constructor(species, speciesKey, pos) {
    this.species = species;
    this.speciesKey = speciesKey;
    this.pos = pos.clone();
    this.vel = new THREE.Vector3(
      (rng() - 0.5) * 2, (rng() - 0.5) * 0.5, (rng() - 0.5) * 2
    ).normalize().multiplyScalar(species.speed * 0.5);
    this.acc = new THREE.Vector3();
    this.age = 0;
    this.alive = true;
    this.dying = false;
    this.fadeIn = 1.0;
    this.swimPhase = rng() * Math.PI * 2;
    this.opacity = 0;
    this.growthScale = 0.4; // start as baby, grow to 1.0
    this.bankAngle = 0; // body roll when turning
    this.prevVelX = 0; // for turn detection

    const color = species.colors[Math.floor(rng() * species.colors.length)];
    const baseColor = new THREE.Color(color);
    // Iridescent fish shader
    this.mat = new THREE.ShaderMaterial({
      side: THREE.DoubleSide, transparent: true,
      uniforms: {
        uColor: { value: baseColor },
        uOpacity: { value: 0 },
        uTime: { value: 0 },
        uIridescence: { value: speciesKey === 'small' ? 0.4 : speciesKey === 'large' ? 0.6 : 0.3 }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vViewDir;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          vNormal = normalize(mat3(modelMatrix) * normal);
          vec4 wp = modelMatrix * vec4(position, 1.0);
          vViewDir = normalize(cameraPosition - wp.xyz);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform float uOpacity;
        uniform float uTime;
        uniform float uIridescence;
        varying vec3 vNormal;
        varying vec3 vViewDir;
        varying vec2 vUv;
        void main() {
          vec3 n = gl_FrontFacing ? vNormal : -vNormal;
          float NdotV = max(dot(n, vViewDir), 0.0);

          // Base diffuse
          vec3 lightDir = normalize(vec3(3.0, 10.0, 5.0));
          float diff = max(dot(n, lightDir), 0.0) * 0.6 + 0.4;

          // Iridescence: hue shift based on view angle
          float iridAngle = pow(1.0 - NdotV, 2.0);
          vec3 iridColor = vec3(
            0.5 + 0.5 * sin(iridAngle * 6.28 + 0.0),
            0.5 + 0.5 * sin(iridAngle * 6.28 + 2.09),
            0.5 + 0.5 * sin(iridAngle * 6.28 + 4.18)
          );

          vec3 color = uColor * diff;
          color = mix(color, iridColor * diff, uIridescence * iridAngle);

          // Specular
          vec3 h = normalize(lightDir + vViewDir);
          float spec = pow(max(dot(n, h), 0.0), 32.0) * 0.4;
          color += spec * vec3(1.0, 0.95, 0.9);

          // Rim light
          float rim = pow(1.0 - NdotV, 3.0) * 0.15;
          color += rim * vec3(0.4, 0.6, 0.9);

          // Scale pattern (subtle)
          float scales = sin(vUv.x * 40.0) * sin(vUv.y * 20.0) * 0.03;
          color += scales;

          gl_FragColor = vec4(color, uOpacity);
        }
      `
    });

    this.mesh = new THREE.Group();

    // Body
    this.body = buildFishBody(speciesKey, species.size);
    this.bodyMesh = new THREE.Mesh(this.body.geo, this.mat);
    this.mesh.add(this.bodyMesh);

    // Tail fin
    const tMul = speciesKey === 'large' ? 1.4 : speciesKey === 'medium' ? 0.8 : 0.5;
    const tailGeo = new THREE.PlaneGeometry(
      species.size * tMul * 0.7,
      species.size * tMul * 1.1,
      1, 4
    );
    // V-notch: indent center of trailing edge
    const tv = tailGeo.attributes.position;
    for (let i = 0; i < tv.count; i++) {
      const y = tv.getY(i);
      const x = tv.getX(i);
      const indentFactor = 1 - Math.abs(y) / (species.size * tMul * 0.55);
      if (x > 0) tv.setX(i, x - indentFactor * species.size * tMul * 0.15);
    }
    tailGeo.computeVertexNormals();
    this.tailMesh = new THREE.Mesh(tailGeo, this.mat);
    this.tailMesh.rotation.y = Math.PI / 2;
    this.tailMesh.position.z = this.body.len * 0.46;
    this.mesh.add(this.tailMesh);

    // Dorsal fin
    const dh = speciesKey === 'large' ? 0.5 : speciesKey === 'medium' ? 0.5 : 0.22;
    const dorsalGeo = new THREE.PlaneGeometry(this.body.len * 0.3, species.size * dh, 4, 1);
    // Taper dorsal fin toward tail
    const dv = dorsalGeo.attributes.position;
    for (let i = 0; i < dv.count; i++) {
      const x = dv.getX(i);
      if (x > 0) dv.setY(i, dv.getY(i) * (1 - x / (this.body.len * 0.15) * 0.4));
    }
    dorsalGeo.computeVertexNormals();
    this.dorsalMesh = new THREE.Mesh(dorsalGeo, this.mat);
    this.dorsalMesh.rotation.y = Math.PI / 2;
    const bodyR = species.size * (speciesKey === 'small' ? 0.35 : speciesKey === 'medium' ? 0.28 : 0.42);
    const hsFin = speciesKey === 'medium' ? 1.4 : 1.0;
    this.dorsalMesh.position.set(0, bodyR * hsFin + species.size * dh * 0.3, -this.body.len * 0.05);
    this.mesh.add(this.dorsalMesh);

    // Pectoral fins (small side fins)
    const pSize = species.size * 0.25;
    const pGeo = new THREE.PlaneGeometry(pSize, pSize * 1.5);
    this.leftFin = new THREE.Mesh(pGeo, this.mat);
    this.leftFin.position.set(bodyR * 0.9, -species.size * 0.05, -this.body.len * 0.15);
    this.leftFin.rotation.set(0.2, 0.4, -0.3);
    this.mesh.add(this.leftFin);

    this.rightFin = new THREE.Mesh(pGeo, this.mat);
    this.rightFin.position.set(-bodyR * 0.9, -species.size * 0.05, -this.body.len * 0.15);
    this.rightFin.rotation.set(0.2, -0.4, 0.3);
    this.mesh.add(this.rightFin);

    // Eyes
    const eyeGeo = new THREE.SphereGeometry(species.size * 0.06, 6, 6);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.1, metalness: 0.5 });
    const eyeZ = -this.body.len * 0.4;
    const eyeX = species.size * 0.14;
    const eyeY = species.size * 0.06;
    this.mesh.add(Object.assign(new THREE.Mesh(eyeGeo, eyeMat), { position: new THREE.Vector3(eyeX, eyeY, eyeZ) }));
    this.mesh.add(Object.assign(new THREE.Mesh(eyeGeo, eyeMat), { position: new THREE.Vector3(-eyeX, eyeY, eyeZ) }));

    this.mesh.position.copy(pos);
    scene.add(this.mesh);
  }

  applyForce(f) { this.acc.add(f); }

  update(dt, time) {
    this.vel.add(this.acc);
    const spd = this.vel.length();
    if (spd > this.species.maxSpeed) this.vel.multiplyScalar(this.species.maxSpeed / spd);
    if (spd < this.species.speed * 0.3) this.vel.normalize().multiplyScalar(this.species.speed * 0.3);

    this.pos.addScaledVector(this.vel, dt * 60);
    this.acc.set(0, 0, 0);
    this.age += dt;

    this.mesh.position.copy(this.pos);

    // Fade in for newborns
    if (this.fadeIn > 0) {
      this.fadeIn -= dt * 0.8;
      this.opacity = Math.max(0, 1 - this.fadeIn);
    } else if (this.dying) {
      this.opacity -= dt * 0.4;
      this.pos.y -= dt * 0.3;
      if (this.opacity <= 0) { this.destroy(); return; }
    } else {
      this.opacity = Math.min(1, this.opacity + dt * 2);
    }
    this.mat.uniforms.uOpacity.value = Math.max(0, this.opacity);
    this.mat.uniforms.uTime.value = time;

    // Growth: babies grow over time
    if (this.growthScale < 1) {
      this.growthScale = Math.min(1, this.growthScale + dt * 0.015);
      this.mesh.scale.setScalar(this.growthScale);
    }

    // Smooth rotation toward velocity
    if (spd > 0.01) {
      _lookTarget.copy(this.pos).add(this.vel);
      _lookMat.lookAt(this.pos, _lookTarget, _up);
      _targetQuat.setFromRotationMatrix(_lookMat);
      this.mesh.quaternion.slerp(_targetQuat, Math.min(1, dt * 6));
    }

    // Body banking on turns
    const currentVelX = this.vel.x * Math.cos(-this.mesh.rotation.y) - this.vel.z * Math.sin(-this.mesh.rotation.y);
    const turnRate = (currentVelX - this.prevVelX) / Math.max(dt, 0.001);
    this.prevVelX = currentVelX;
    const targetBank = Math.max(-0.4, Math.min(0.4, -turnRate * 0.08));
    this.bankAngle += (targetBank - this.bankAngle) * Math.min(1, dt * 4);
    // Apply bank as local Z rotation on body mesh
    this.bodyMesh.rotation.z = this.bankAngle;

    // Body undulation (sine wave along spine, stronger at tail)
    const bd = this.body;
    const positions = bd.geo.attributes.position;
    const swimFreq = 4 + spd * 2;
    const phase = this.swimPhase + time * swimFreq;

    for (let s = 0; s <= bd.SEGS; s++) {
      const t = s / bd.SEGS; // 0=tail, 1=head
      const amp = (1 - t) * this.species.size * 0.12;
      const wave = Math.sin(t * 7 - phase) * amp;
      for (let j = 0; j <= bd.RING; j++) {
        const idx = (s * (bd.RING + 1) + j) * 3;
        positions.array[idx] = bd.rest[idx] + wave;
      }
    }
    positions.needsUpdate = true;
    bd.geo.computeVertexNormals();

    // Tail wag synchronized with body wave
    this.tailMesh.rotation.z = Math.sin(phase) * 0.35;

    // Dorsal fin flutter
    this.dorsalMesh.rotation.z = Math.sin(time * 3 + this.swimPhase) * 0.04;

    // Pectoral fin flutter
    const pFlutter = Math.sin(time * 6 + this.swimPhase) * 0.15;
    this.leftFin.rotation.z = -0.3 + pFlutter;
    this.rightFin.rotation.z = 0.3 - pFlutter;
  }

  destroy() {
    this.alive = false;
    scene.remove(this.mesh);
    this.body.geo.dispose();
    this.mat.dispose();
    // Dispose all child geometries
    this.mesh.traverse(child => {
      if (child.geometry) child.geometry.dispose();
      if (child.material && child.material !== this.mat) child.material.dispose();
    });
  }
}

// Boids rules
const _sep = new THREE.Vector3();
const _ali = new THREE.Vector3();
const _coh = new THREE.Vector3();
const _steer = new THREE.Vector3();
const _diff = new THREE.Vector3();

function boids(fish, allFish, dt) {
  const sp = fish.species;
  _sep.set(0, 0, 0);
  _ali.set(0, 0, 0);
  _coh.set(0, 0, 0);
  let sepCount = 0, aliCount = 0, cohCount = 0;

  for (let i = 0; i < allFish.length; i++) {
    const other = allFish[i];
    if (other === fish || !other.alive) continue;
    _diff.subVectors(fish.pos, other.pos);
    const dist = _diff.length();

    // Separation (all species)
    if (dist < sp.separationDist && dist > 0) {
      _diff.normalize().divideScalar(dist);
      _sep.add(_diff);
      sepCount++;
    }

    // Alignment & cohesion (same species only)
    if (other.species === sp && dist < sp.neighborDist) {
      _ali.add(other.vel);
      aliCount++;
      _coh.add(other.pos);
      cohCount++;
    }
  }

  // Apply separation
  if (sepCount > 0) {
    _sep.divideScalar(sepCount).normalize().multiplyScalar(sp.maxSpeed);
    _sep.sub(fish.vel).clampLength(0, sp.maxForce * 1.5);
    fish.applyForce(_sep);
  }

  // Apply alignment
  if (aliCount > 0) {
    _ali.divideScalar(aliCount).normalize().multiplyScalar(sp.maxSpeed);
    _ali.sub(fish.vel).clampLength(0, sp.maxForce);
    fish.applyForce(_ali.multiplyScalar(sp.alignWeight));
  }

  // Apply cohesion
  if (cohCount > 0) {
    _coh.divideScalar(cohCount).sub(fish.pos);
    _coh.normalize().multiplyScalar(sp.maxSpeed);
    _coh.sub(fish.vel).clampLength(0, sp.maxForce);
    fish.applyForce(_coh.multiplyScalar(sp.cohesionWeight));
  }

  // Wall avoidance — stay inside the bowl sphere
  const distFromCenter = fish.pos.length();
  if (distFromCenter > BOWL_INNER * 0.7) {
    const pushStrength = Math.pow((distFromCenter - BOWL_INNER * 0.7) / (BOWL_INNER * 0.3), 2);
    _steer.copy(fish.pos).normalize().multiplyScalar(-sp.maxForce * 3 * pushStrength);
    fish.applyForce(_steer);
  }

  // Stay below water, above sand
  if (fish.pos.y > WATER_Y - 0.5) {
    fish.applyForce(new THREE.Vector3(0, -sp.maxForce * 2, 0));
  }
  if (fish.pos.y < SAND_Y + 0.5 + sp.size) {
    fish.applyForce(new THREE.Vector3(0, sp.maxForce * 2, 0));
  }

  // Gentle tendency to stay in mid-water
  const idealY = (SAND_Y + WATER_Y) * 0.5 - 0.5;
  const yDiff = idealY - fish.pos.y;
  fish.applyForce(new THREE.Vector3(0, yDiff * sp.maxForce * 0.1, 0));

  // Predator avoidance — flee from species that eat us
  if (sp.predators.length > 0) {
    for (let i = 0; i < allFish.length; i++) {
      const other = allFish[i];
      if (other === fish || !other.alive || other.dying) continue;
      if (!sp.predators.includes(other.speciesKey)) continue;
      _diff.subVectors(fish.pos, other.pos);
      const dist = _diff.length();
      if (dist < sp.neighborDist * 1.5 && dist > 0) {
        _diff.normalize().multiplyScalar(sp.maxForce * 3 / Math.max(dist * 0.3, 0.1));
        fish.applyForce(_diff);
      }
    }
  }

  // Prey chasing — hunt species we eat
  if (sp.prey.length > 0 && !fish.dying) {
    let closestPrey = null, closestDist = Infinity;
    for (let i = 0; i < allFish.length; i++) {
      const other = allFish[i];
      if (other === fish || !other.alive || other.dying) continue;
      if (!sp.prey.includes(other.speciesKey)) continue;
      const dist = fish.pos.distanceTo(other.pos);
      if (dist < closestDist && dist < sp.neighborDist * 2) {
        closestDist = dist;
        closestPrey = other;
      }
    }
    if (closestPrey) {
      _steer.subVectors(closestPrey.pos, fish.pos).normalize().multiplyScalar(sp.maxForce * 1.2);
      fish.applyForce(_steer);
    }
  }

  // Food attraction
  if (foodParticles.length > 0) {
    let closestFood = null, closestFoodDist = Infinity;
    for (const food of foodParticles) {
      if (food.eaten) continue;
      const d = fish.pos.distanceTo(food.pos);
      if (d < closestFoodDist && d < sp.neighborDist * 3) {
        closestFoodDist = d;
        closestFood = food;
      }
    }
    if (closestFood) {
      _steer.subVectors(closestFood.pos, fish.pos).normalize().multiplyScalar(sp.maxForce * 2.5);
      fish.applyForce(_steer);
      if (closestFoodDist < sp.size * 1.5) closestFood.eaten = true;
    }
  }

  // Mouse scatter — flee from mouse near glass
  if (mouseWorldPos) {
    const dist = fish.pos.distanceTo(mouseWorldPos);
    if (dist < 2.5) {
      _steer.subVectors(fish.pos, mouseWorldPos).normalize();
      _steer.multiplyScalar(sp.maxForce * 4 / Math.max(dist * 0.5, 0.3));
      fish.applyForce(_steer);
    }
  }
}

// Species definitions
const SPECIES = {
  small: {
    name: 'Neon Tetra',
    size: 0.2,
    speed: 1.2,
    maxSpeed: 2.0,
    maxForce: 0.06,
    separationDist: 0.6,
    neighborDist: 2.5,
    alignWeight: 1.0,
    cohesionWeight: 1.0,
    colors: [0x00aaff, 0x0088dd, 0x44ccff, 0x2299ee],
    predators: ['medium', 'large'],
    prey: [],
    schooling: true,
    lifespan: 150, maturityAge: 20, reproChance: 0.4, maxPop: 25, minPop: 5
  },
  medium: {
    name: 'Angelfish',
    size: 0.4,
    speed: 0.8,
    maxSpeed: 1.5,
    maxForce: 0.04,
    separationDist: 1.0,
    neighborDist: 3.0,
    alignWeight: 0.7,
    cohesionWeight: 0.6,
    colors: [0xffcc44, 0xffaa22, 0xeebb55, 0xffd866],
    predators: ['large'],
    prey: ['small'],
    schooling: true,
    lifespan: 240, maturityAge: 30, reproChance: 0.25, maxPop: 12, minPop: 3
  },
  large: {
    name: 'Betta',
    size: 0.7,
    speed: 0.5,
    maxSpeed: 1.2,
    maxForce: 0.03,
    separationDist: 1.5,
    neighborDist: 4.0,
    alignWeight: 0.2,
    cohesionWeight: 0.1,
    colors: [0xcc22ff, 0xaa00dd, 0x8833cc, 0xbb44ee],
    predators: [],
    prey: ['small', 'medium'],
    schooling: false,
    lifespan: 400, maturityAge: 50, reproChance: 0.15, maxPop: 5, minPop: 1
  }
};

// Spawn initial fish
function spawnFish(speciesKey, count) {
  const sp = SPECIES[speciesKey];
  for (let i = 0; i < count; i++) {
    const angle = rng() * Math.PI * 2;
    const r = 1 + rng() * 2;
    const y = SAND_Y + 1.5 + rng() * (WATER_Y - SAND_Y - 3);
    const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
    fishList.push(new Fish(sp, speciesKey, pos));
  }
}

spawnFish('small', 18);
spawnFish('medium', 8);
spawnFish('large', 3);

// ================================================================
// ECOSYSTEM — food chain, reproduction, lifespan
// ================================================================

let ecoTimer = 0;
const ECO_TICK = 5; // seconds between ecosystem checks

function countSpecies() {
  const c = { small: 0, medium: 0, large: 0 };
  for (const f of fishList) if (f.alive && !f.dying) c[f.speciesKey]++;
  return c;
}

function checkEating() {
  for (let i = 0; i < fishList.length; i++) {
    const pred = fishList[i];
    if (!pred.alive || pred.dying || pred.species.prey.length === 0) continue;

    for (let j = 0; j < fishList.length; j++) {
      const prey = fishList[j];
      if (!prey.alive || prey.dying || pred === prey) continue;
      if (!pred.species.prey.includes(prey.speciesKey)) continue;

      const dist = pred.pos.distanceTo(prey.pos);
      const eatDist = (pred.species.size + prey.species.size) * 0.6;
      if (dist < eatDist) {
        const counts = countSpecies();
        if (counts[prey.speciesKey] > prey.species.minPop) {
          prey.dying = true;
          prey.opacity = prey.mat.uniforms.uOpacity.value;
          // Predator grows slightly
          pred.mesh.scale.multiplyScalar(1.01);
        }
      }
    }
  }
}

function updateEcosystem(dt) {
  // Eating happens every frame
  checkEating();

  ecoTimer += dt;
  if (ecoTimer < ECO_TICK) return;
  ecoTimer = 0;

  const counts = countSpecies();

  // Reproduction
  for (const key of ['small', 'medium', 'large']) {
    const sp = SPECIES[key];
    if (counts[key] >= 2 && counts[key] < sp.maxPop && Math.random() < sp.reproChance) {
      const parents = fishList.filter(f => f.alive && !f.dying && f.speciesKey === key && f.age > sp.maturityAge);
      if (parents.length >= 2) {
        const parent = parents[Math.floor(Math.random() * parents.length)];
        const offset = new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.3,
          (Math.random() - 0.5) * 0.5
        );
        const baby = new Fish(sp, key, parent.pos.clone().add(offset));
        fishList.push(baby);
      }
    }
  }

  // Lifespan — old fish start dying
  for (const f of fishList) {
    if (!f.alive || f.dying) continue;
    if (f.age > f.species.lifespan) {
      const counts2 = countSpecies();
      if (counts2[f.speciesKey] > f.species.minPop) {
        f.dying = true;
        f.opacity = f.mat.uniforms.uOpacity.value;
      }
    }
  }

  // Respawn protection: if any species is below minimum, spawn one
  const counts3 = countSpecies();
  for (const key of ['small', 'medium', 'large']) {
    const sp = SPECIES[key];
    if (counts3[key] < sp.minPop) {
      const angle = Math.random() * Math.PI * 2;
      const r = 1 + Math.random() * 2;
      const y = SAND_Y + 1.5 + Math.random() * (WATER_Y - SAND_Y - 3);
      const pos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
      fishList.push(new Fish(sp, key, pos));
    }
  }

  // Garbage collect dead fish
  for (let i = fishList.length - 1; i >= 0; i--) {
    if (!fishList[i].alive) fishList.splice(i, 1);
  }
}

// ================================================================
// INTERACTION — feeding, mouse scatter
// ================================================================

const raycaster = new THREE.Raycaster();
const mouseNDC = new THREE.Vector2();
const foodParticles = [];
let mouseWorldPos = null;
let mouseScreenX = innerWidth / 2, mouseScreenY = innerHeight / 2;

function dropFood(worldPos) {
  const count = 3 + Math.floor(Math.random() * 3);
  for (let i = 0; i < count; i++) {
    const geo = new THREE.SphereGeometry(0.04, 6, 6);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xffbb55, emissive: 0x553311, emissiveIntensity: 0.5, roughness: 0.3
    });
    const mesh = new THREE.Mesh(geo, mat);
    const offset = new THREE.Vector3(
      (Math.random() - 0.5) * 0.4, 0, (Math.random() - 0.5) * 0.4
    );
    mesh.position.copy(worldPos).add(offset);
    scene.add(mesh);
    foodParticles.push({
      mesh,
      pos: mesh.position.clone(),
      vel: new THREE.Vector3((Math.random() - 0.5) * 0.1, -0.4, (Math.random() - 0.5) * 0.1),
      life: 20,
      eaten: false
    });
  }
}

function updateFood(dt) {
  for (let i = foodParticles.length - 1; i >= 0; i--) {
    const f = foodParticles[i];
    f.life -= dt;
    f.pos.addScaledVector(f.vel, dt);
    f.vel.y *= 0.98;
    if (f.pos.y < SAND_Y + 0.1) { f.pos.y = SAND_Y + 0.1; f.vel.set(0, 0, 0); }
    f.mesh.position.copy(f.pos);
    // Fade out near end of life
    if (f.life < 3) f.mesh.material.opacity = f.life / 3;
    if (f.life <= 0 || f.eaten) {
      scene.remove(f.mesh);
      f.mesh.geometry.dispose();
      f.mesh.material.dispose();
      foodParticles.splice(i, 1);
    }
  }
}

function handleClick(e) {
  mouseNDC.set(
    (e.clientX / innerWidth) * 2 - 1,
    -(e.clientY / innerHeight) * 2 + 1
  );
  raycaster.setFromCamera(mouseNDC, camera);
  const waterPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -WATER_Y);
  const hit = new THREE.Vector3();
  raycaster.ray.intersectPlane(waterPlane, hit);
  if (hit) {
    const dist = Math.sqrt(hit.x * hit.x + hit.z * hit.z);
    const maxR = Math.sqrt(BOWL_RADIUS * BOWL_RADIUS - WATER_Y * WATER_Y) - 0.3;
    if (dist < maxR) dropFood(hit);
  }
}

function updateMouseScatter() {
  mouseNDC.set(
    (mouseScreenX / innerWidth) * 2 - 1,
    -(mouseScreenY / innerHeight) * 2 + 1
  );
  raycaster.setFromCamera(mouseNDC, camera);
  // Intersect ray with bowl sphere
  const o = raycaster.ray.origin, d = raycaster.ray.direction;
  const a = d.dot(d), b = 2 * o.dot(d), c = o.dot(o) - BOWL_RADIUS * BOWL_RADIUS;
  const disc = b * b - 4 * a * c;
  if (disc >= 0) {
    const t = (-b - Math.sqrt(disc)) / (2 * a);
    if (t > 0) { mouseWorldPos = o.clone().addScaledVector(d, t); return; }
  }
  mouseWorldPos = null;
}

// ================================================================
// CAMERA CONTROLS
// ================================================================

let camRadius = 13, camPhi = 1.05, camTheta = 0;
let dragging = false, prevMX = 0, prevMY = 0;
let clickStartX = 0, clickStartY = 0;
const canvas = renderer.domElement;

canvas.addEventListener('mousedown', e => {
  dragging = true; prevMX = e.clientX; prevMY = e.clientY;
  clickStartX = e.clientX; clickStartY = e.clientY;
});
canvas.addEventListener('mousemove', e => {
  mouseScreenX = e.clientX;
  mouseScreenY = e.clientY;
  if (!dragging) return;
  camTheta -= (e.clientX - prevMX) * 0.005;
  camPhi = Math.max(0.3, Math.min(Math.PI * 0.48, camPhi - (e.clientY - prevMY) * 0.005));
  prevMX = e.clientX; prevMY = e.clientY;
});
canvas.addEventListener('mouseup', e => {
  dragging = false;
  const dx = e.clientX - clickStartX, dy = e.clientY - clickStartY;
  if (dx * dx + dy * dy < 25) handleClick(e);
});
canvas.addEventListener('mouseleave', () => { dragging = false; mouseWorldPos = null; });
canvas.addEventListener('wheel', e => {
  camRadius = Math.max(7, Math.min(22, camRadius + e.deltaY * 0.01));
}, { passive: true });

// Touch support
canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    dragging = true;
    prevMX = e.touches[0].clientX; prevMY = e.touches[0].clientY;
    clickStartX = prevMX; clickStartY = prevMY;
  }
}, { passive: true });
canvas.addEventListener('touchmove', e => {
  if (!dragging || e.touches.length !== 1) return;
  camTheta -= (e.touches[0].clientX - prevMX) * 0.005;
  camPhi = Math.max(0.3, Math.min(Math.PI * 0.48, camPhi - (e.touches[0].clientY - prevMY) * 0.005));
  prevMX = e.touches[0].clientX; prevMY = e.touches[0].clientY;
}, { passive: true });
canvas.addEventListener('touchend', e => {
  dragging = false;
  const dx = prevMX - clickStartX, dy = prevMY - clickStartY;
  if (dx * dx + dy * dy < 25) handleClick({ clientX: prevMX, clientY: prevMY });
});

// ================================================================
// HUD
// ================================================================

const hudSmall = document.getElementById('count-small');
const hudMedium = document.getElementById('count-medium');
const hudLarge = document.getElementById('count-large');
const hudDay = document.getElementById('day-counter');
let hudTimer = 0;
let dayCount = 0;
let dayAccum = 0;

const hudTimeOfDay = document.getElementById('time-of-day');

function getTimeOfDayLabel(phase) {
  if (phase < 0.08) return 'Dawn';
  if (phase < 0.15) return 'Sunrise';
  if (phase < 0.3) return 'Morning';
  if (phase < 0.45) return 'Midday';
  if (phase < 0.5) return 'Afternoon';
  if (phase < 0.58) return 'Sunset';
  if (phase < 0.65) return 'Dusk';
  if (phase < 0.82) return 'Night';
  return 'Late Night';
}

function updateHUD(dt, time) {
  hudTimer += dt;
  if (hudTimer < 0.5) return;
  hudTimer = 0;
  const c = countSpecies();
  hudSmall.textContent = c.small;
  hudMedium.textContent = c.medium;
  hudLarge.textContent = c.large;
  const phase = getDayPhase(time);
  hudTimeOfDay.textContent = getTimeOfDayLabel(phase);
}

function updateDay(dt) {
  dayAccum += dt;
  if (dayAccum >= 60) { // 1 minute = 1 day
    dayAccum -= 60;
    dayCount++;
    hudDay.textContent = 'Day ' + (dayCount + 1);
  }
}

// Feed button (for mobile)
document.getElementById('feed-btn').addEventListener('click', e => {
  e.stopPropagation();
  // Drop food at a random position near center of bowl
  const angle = Math.random() * Math.PI * 2;
  const r = Math.random() * 1.5;
  const pos = new THREE.Vector3(Math.cos(angle) * r, WATER_Y, Math.sin(angle) * r);
  dropFood(pos);
});

// Fade out hint after 8 seconds
const hintEl = document.querySelector('.hint');
setTimeout(() => {
  hintEl.style.transition = 'opacity 2s';
  hintEl.style.opacity = '0';
  setTimeout(() => hintEl.remove(), 2000);
}, 8000);

// ================================================================
// DAY/NIGHT CYCLE
// ================================================================

// One full cycle = 4 minutes (dawn -> day -> dusk -> night -> dawn)
const DAY_CYCLE_DURATION = 240; // seconds

function getDayPhase(time) {
  const t = (time % DAY_CYCLE_DURATION) / DAY_CYCLE_DURATION; // 0-1
  // 0-0.15 dawn, 0.15-0.5 day, 0.5-0.65 dusk, 0.65-1.0 night
  return t;
}

function getDayLighting(phase) {
  let sunIntensity, sunColor, ambientIntensity, ambientColor, exposure;

  if (phase < 0.15) {
    // Dawn: warm orange sunrise
    const t = phase / 0.15;
    sunIntensity = 0.3 + t * 0.7;
    sunColor = new THREE.Color().lerpColors(
      new THREE.Color(0.4, 0.2, 0.1), new THREE.Color(1.0, 0.85, 0.7), t
    );
    ambientIntensity = 0.2 + t * 0.3;
    ambientColor = new THREE.Color().lerpColors(
      new THREE.Color(0.15, 0.1, 0.2), new THREE.Color(0.2, 0.25, 0.35), t
    );
    exposure = 0.8 + t * 0.5;
  } else if (phase < 0.5) {
    // Day: bright, slightly warm
    const t = (phase - 0.15) / 0.35;
    sunIntensity = 1.0;
    sunColor = new THREE.Color(1.0, 0.93, 0.85);
    ambientIntensity = 0.5;
    ambientColor = new THREE.Color(0.2, 0.27, 0.4);
    exposure = 1.3 - Math.sin(t * Math.PI) * 0.1; // slight noon peak
  } else if (phase < 0.65) {
    // Dusk: golden/purple
    const t = (phase - 0.5) / 0.15;
    sunIntensity = 1.0 - t * 0.7;
    sunColor = new THREE.Color().lerpColors(
      new THREE.Color(1.0, 0.85, 0.6), new THREE.Color(0.6, 0.2, 0.15), t
    );
    ambientIntensity = 0.5 - t * 0.3;
    ambientColor = new THREE.Color().lerpColors(
      new THREE.Color(0.25, 0.2, 0.3), new THREE.Color(0.1, 0.05, 0.15), t
    );
    exposure = 1.3 - t * 0.6;
  } else {
    // Night: deep blue, moonlit
    const t = (phase - 0.65) / 0.35;
    const pulse = 0.5 + 0.5 * Math.sin(t * Math.PI); // peaks mid-night
    sunIntensity = 0.15 + pulse * 0.1;
    sunColor = new THREE.Color(0.3, 0.35, 0.6);
    ambientIntensity = 0.15 + pulse * 0.05;
    ambientColor = new THREE.Color(0.05, 0.08, 0.2);
    exposure = 0.6 + pulse * 0.15;
  }

  return { sunIntensity, sunColor, ambientIntensity, ambientColor, exposure };
}

// ================================================================
// RENDER LOOP
// ================================================================

let lastTime = 0;

function animate(now) {
  requestAnimationFrame(animate);
  const time = now * 0.001;
  const dt = Math.min(time - lastTime, 0.05);
  lastTime = time;
  if (dt <= 0) return;

  // Day/night cycle
  const dayPhase = getDayPhase(time);
  const dayLight = getDayLighting(dayPhase);
  sunLight.intensity = dayLight.sunIntensity;
  sunLight.color.copy(dayLight.sunColor);
  scene.children[0].intensity = dayLight.ambientIntensity; // ambient light
  scene.children[0].color.copy(dayLight.ambientColor);
  renderer.toneMappingExposure = dayLight.exposure;
  // Underwater glow responds to day cycle
  underwaterGlow.intensity = 0.2 + dayLight.sunIntensity * 0.3;

  // Auto-rotate when not dragging
  if (!dragging) camTheta += 0.04 * dt;

  // Update camera
  camera.position.set(
    camRadius * Math.sin(camPhi) * Math.sin(camTheta),
    camRadius * Math.cos(camPhi),
    camRadius * Math.sin(camPhi) * Math.cos(camTheta)
  );
  camera.lookAt(0, -0.5, 0);

  // Water waves
  waterMat.uniforms.uTime.value = time;

  // Sand caustics
  sandMat.uniforms.uTime.value = time;

  // God rays
  for (const grMat of godRays) grMat.uniforms.uTime.value = time;

  // Background color shift + day phase
  bgMat.uniforms.uTime.value = time;
  bgMat.uniforms.uDayPhase.value = dayPhase;

  // Particle drift
  const pp = particleGeo.attributes.position;
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    let y = pp.getY(i) + particleSpeeds[i] * dt * 60;
    if (y > WATER_Y - 0.3) {
      y = SAND_Y + 0.5;
      const a = Math.random() * Math.PI * 2, r = Math.random() * 3;
      pp.setX(i, Math.cos(a) * r);
      pp.setZ(i, Math.sin(a) * r);
    }
    pp.setY(i, y);
  }
  pp.needsUpdate = true;

  // Bubble rise
  const bp = bubbleGeo.attributes.position;
  for (let i = 0; i < BUBBLE_COUNT; i++) {
    let by = bp.getY(i) + bubbleSpeeds2[i] * dt;
    // Wobble horizontally
    const wobble = Math.sin(time * 2 + bubblePhases[i]) * 0.005;
    bp.setX(i, bp.getX(i) + wobble);
    bp.setZ(i, bp.getZ(i) + Math.cos(time * 1.5 + bubblePhases[i] * 1.3) * 0.003);
    bubbleLifes[i] -= dt;
    if (by > WATER_Y - 0.2 || bubbleLifes[i] <= 0) resetBubble(i);
    else bp.setY(i, by);
  }
  bp.needsUpdate = true;

  // Seaweed sway (shader-driven)
  seaweeds.forEach(sw => { sw.mat.uniforms.uTime.value = time; });

  // Fish boids + update
  for (let i = 0; i < fishList.length; i++) {
    if (!fishList[i].alive) continue;
    boids(fishList[i], fishList, dt);
    fishList[i].update(dt, time);
  }

  // Ecosystem tick
  updateEcosystem(dt);

  // Food particles
  updateFood(dt);

  // Mouse scatter update
  if (!dragging) updateMouseScatter();

  // HUD
  updateHUD(dt, time);
  updateDay(dt);

  renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// ================================================================
// RESIZE
// ================================================================

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

</script>
</body>
</html>
